
% Default to the notebook output style

    


% Inherit from the specified cell style.




    
\documentclass[11pt]{article}

    
    
    \usepackage[T1]{fontenc}
    % Nicer default font (+ math font) than Computer Modern for most use cases
    \usepackage{mathpazo}

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % We will generate all images so they have a width \maxwidth. This means
    % that they will get their normal width if they fit onto the page, but
    % are scaled down if they would overflow the margins.
    \makeatletter
    \def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth
    \else\Gin@nat@width\fi}
    \makeatother
    \let\Oldincludegraphics\includegraphics
    % Set max figure width to be 80% of text width, for now hardcoded.
    \renewcommand{\includegraphics}[1]{\Oldincludegraphics[width=.8\maxwidth]{#1}}
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionLabelFormat{nolabel}{}
    \captionsetup{labelformat=nolabel}

    \usepackage{adjustbox} % Used to constrain images to a maximum size 
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage[utf8x]{inputenc} % Allow utf-8 characters in the tex document
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range 
    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    

    
    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatability definitions
    \def\gt{>}
    \def\lt{<}
    % Document parameters
    \title{notebook}
    
    
    

    % Pygments definitions
    
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@dl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@ch\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@fm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@mb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@cpf\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sa\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % Exact colors from NB
    \definecolor{incolor}{rgb}{0.0, 0.0, 0.5}
    \definecolor{outcolor}{rgb}{0.545, 0.0, 0.0}



    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

    \begin{document}
    
    
    \maketitle
    
    

    
    \hypertarget{analysis-of-a-dataset-using-data-mining-techniques.}{%
\section{Analysis of a dataset using data mining
techniques.}\label{analysis-of-a-dataset-using-data-mining-techniques.}}

This notebook focuses on exploring and mining basic information from an
anonymised retail transactions dataset given by the company Instacart.

\hypertarget{taking-a-first-glance-at-the-dataset}{%
\subsection{Taking a first glance at the
dataset}\label{taking-a-first-glance-at-the-dataset}}

\emph{Source code for this section may be find in file
\texttt{dist/first-glance.class.ts}}

The dataset consists of information about 3.4 million grocery orders,
distributed across 6 \texttt{.csv} files listed below:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{child\PYZus{}process} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}child\PYZus{}process\PYZsq{}}\PY{p}{;}
        
        \PY{c+cm}{/**}
        \PY{c+cm}{ * Function executes a child\PYZus{}process listing the files in the instacart\PYZus{}basket\PYZus{}data folder}
        \PY{c+cm}{ * and returns the listed files though a Promise.}
        \PY{c+cm}{ */}
        \PY{k+kd}{function} \PY{n+nx}{listFiles}\PY{p}{(}\PY{p}{)}\PY{o}{:} \PY{n+nx}{Promise}\PY{o}{\PYZlt{}}\PY{k+kt}{string}\PY{p}{[}\PY{p}{]}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
            \PY{c+c1}{// Async behavior}
            \PY{k}{return} \PY{k}{new} \PY{n+nx}{Promise}\PY{p}{(} \PY{p}{(}\PY{n+nx}{resolve}\PY{p}{,}\PY{n+nx}{reject}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                \PY{c+c1}{// Listing the files in the instacart\PYZus{}basket\PYZus{}data folder.}
                \PY{k+kd}{let} \PY{n+nx}{ls}: \PY{k+kt}{child\PYZus{}process.ChildProcess} \PY{o}{=} \PY{n+nx}{child\PYZus{}process}\PY{p}{.}\PY{n+nx}{exec}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}ls instacart\PYZus{}basket\PYZus{}data\PYZsq{}}\PY{p}{,} \PY{p}{(}\PY{n+nx}{err}: \PY{k+kt}{Error}\PY{p}{,} \PY{n+nx}{stdout}: \PY{k+kt}{string}\PY{p}{,} \PY{n+nx}{stderr}: \PY{k+kt}{string}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                    \PY{c+c1}{// Formatting ls output as an Array of strings (representing the file names)}
                    \PY{n+nx}{resolve}\PY{p}{(}\PY{n+nx}{stdout}\PY{p}{.}\PY{n+nx}{match}\PY{p}{(}\PY{l+s+sr}{/[\PYZca{}\PYZbs{}r\PYZbs{}n]+/g}\PY{p}{)}\PY{p}{)}\PY{p}{;}
                \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
            \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
        \PY{p}{\PYZcb{}}
        
        \PY{k+kd}{function} \PY{n+nx}{showFiles}\PY{p}{(}\PY{p}{)}\PY{o}{:} \PY{k}{void} \PY{p}{\PYZob{}}
            \PY{c+c1}{// Async console for Jupyter}
            \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}async}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}} \PY{o}{=} \PY{k+kc}{true}\PY{p}{;}
        
            \PY{n+nx}{listFiles}\PY{p}{(}\PY{p}{)}\PY{p}{.}\PY{n+nx}{then}\PY{p}{(} \PY{p}{(}\PY{n+nx}{files}: \PY{k+kt}{string}\PY{p}{[}\PY{p}{]}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{n+nx}{files}\PY{p}{)}\PY{p}{;}
                \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}done}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{(}\PY{p}{)}\PY{p}{;}
            \PY{p}{\PYZcb{}}\PY{p}{,} \PY{p}{(}\PY{n+nx}{e}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{n+nx}{e}\PY{p}{)} \PY{p}{)}\PY{p}{;}
        \PY{p}{\PYZcb{}}
        
        \PY{n+nx}{showFiles}\PY{p}{(}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
[ 'aisles.csv',
  'departments.csv',
  'order\_products\_\_prior.csv',
  'order\_products\_\_train.csv',
  'orders.csv',
  'products.csv' ]

    \end{Verbatim}

    Files composing the dataset are listed below:

\begin{verbatim}
[ 'aisles.csv',
  'departments.csv',
  'order_products__prior.csv',
  'order_products__train.csv',
  'orders.csv',
  'products.csv' ]
\end{verbatim}

As a starting point, in order to have a first glance of the data we will
actually be playing with throughout this entire report; let us display
the first items composing each \texttt{.csv} file listed above.

We will use NodeJS's straight-forward File I/O fs to list, open and
\texttt{\textquotesingle{}csv-parse\textquotesingle{}}'s \texttt{Parser}
to parse \texttt{.csv} files.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{fs} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}fs\PYZsq{}}\PY{p}{;}
        \PY{k+kr}{import} \PY{p}{\PYZob{}} \PY{n+nx}{Parser} \PY{p}{\PYZcb{}} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}csv\PYZhy{}parse\PYZsq{}}\PY{p}{;}
        
        \PY{c+cm}{/**}
        \PY{c+cm}{ * Function reads a .csv file and returns it properlly formatted.}
        \PY{c+cm}{ */}
        \PY{k+kd}{function} \PY{n+nx}{readFile}\PY{o}{\PYZlt{}}\PY{n+nx}{T}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{n+nx}{filePath}: \PY{k+kt}{string}\PY{p}{)}\PY{o}{:} \PY{n+nx}{Promise}\PY{o}{\PYZlt{}}\PY{p}{\PYZob{}} \PY{n+nx}{data}:\PY{k+kt}{Array}\PY{o}{\PYZlt{}}\PY{n+nx}{T}\PY{o}{\PYZgt{}}\PY{p}{,} \PY{n+nx}{file}: \PY{k+kt}{string} \PY{p}{\PYZcb{}}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
            \PY{c+c1}{// Async console for Jupyter}
            \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}async}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}} \PY{o}{=} \PY{k+kc}{true}\PY{p}{;}
            \PY{c+c1}{// Async behavior}
            \PY{k}{return} \PY{k}{new} \PY{n+nx}{Promise}\PY{p}{(} \PY{p}{(}\PY{n+nx}{resolve}\PY{p}{,} \PY{n+nx}{reject}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                \PY{k+kd}{let} \PY{n+nx}{ret}: \PY{k+kt}{Array}\PY{o}{\PYZlt{}}\PY{n+nx}{T}\PY{o}{\PYZgt{}} \PY{o}{=} \PY{p}{[}\PY{p}{]}\PY{p}{;}
        
                \PY{c+c1}{// \PYZsq{}csv\PYZhy{}parse\PYZsq{} Parser, columns options groups each row by column in an object}
                \PY{k+kd}{let} \PY{n+nx}{parser}: \PY{k+kt}{Parser} \PY{o}{=} \PY{k}{new} \PY{n+nx}{Parser}\PY{p}{(}\PY{p}{\PYZob{}}
                        \PY{n+nx}{delimiter}\PY{o}{:} \PY{l+s+s1}{\PYZsq{},\PYZsq{}}\PY{p}{,}
                        \PY{n+nx}{columns}: \PY{k+kt}{true}
                \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
        
                \PY{n+nx}{parser}
                    \PY{p}{.}\PY{n+nx}{on}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}data\PYZsq{}}\PY{p}{,} \PY{p}{(}\PY{n+nx}{data}: \PY{k+kt}{T}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{ret}\PY{p}{.}\PY{n+nx}{push}\PY{p}{(}\PY{n+nx}{data}\PY{p}{)} \PY{p}{)}
                    \PY{p}{.}\PY{n+nx}{on}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}error\PYZsq{}}\PY{p}{,} \PY{p}{(}\PY{n+nx}{error}: \PY{k+kt}{any}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{reject}\PY{p}{(}\PY{n+nx}{error}\PY{p}{)} \PY{p}{)}
                    \PY{p}{.}\PY{n+nx}{on}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}end\PYZsq{}}\PY{p}{,} \PY{p}{(}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{resolve}\PY{p}{(}\PY{p}{\PYZob{}}\PY{n+nx}{data}: \PY{k+kt}{ret}\PY{p}{,} \PY{n+nx}{file}: \PY{k+kt}{filePath}\PY{p}{\PYZcb{}}\PY{p}{)} \PY{p}{)}\PY{p}{;}
        
                \PY{c+c1}{// Reading the file and piping to parser}
                \PY{n+nx}{fs}\PY{p}{.}\PY{n+nx}{createReadStream}\PY{p}{(}\PY{n+nx}{filePath}\PY{p}{)}\PY{p}{.}\PY{n+nx}{pipe}\PY{p}{(}\PY{n+nx}{parser}\PY{p}{)}\PY{p}{;}
            \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
        \PY{p}{\PYZcb{}}
        
        \PY{n+nx}{listFiles}\PY{p}{(}\PY{p}{)}\PY{p}{.}\PY{n+nx}{then}\PY{p}{(} \PY{p}{(}\PY{n+nx}{files}: \PY{k+kt}{string}\PY{p}{[}\PY{p}{]}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
            \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Parsing all the files, this may a while...\PYZsq{}}\PY{p}{)}\PY{p}{;}
            \PY{c+c1}{// Creating promises array to run readFile() of files concurrently}
            \PY{k+kd}{let} \PY{n+nx}{promises}: \PY{k+kt}{Promise}\PY{o}{\PYZlt{}}\PY{n+nx}{any}\PY{o}{\PYZgt{}}\PY{p}{[}\PY{p}{]} \PY{o}{=} \PY{n+nx}{files}\PY{p}{.}\PY{n+nx}{map}\PY{p}{(} \PY{p}{(}\PY{n+nx}{file}: \PY{k+kt}{string}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                \PY{c+c1}{// Formatting to get absolute paths to files.}
                \PY{k+kd}{let} \PY{n+nx}{filePath}: \PY{k+kt}{string} \PY{o}{=} \PY{l+s+sb}{`}\PY{l+s+sb}{custom\PYZus{}data/small\PYZus{}}\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{file}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{`}\PY{p}{;}
                \PY{c+c1}{// Reading file}
                \PY{k}{return} \PY{n+nx}{readFile}\PY{o}{\PYZlt{}}\PY{n+nx}{any}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{n+nx}{filePath}\PY{p}{)}\PY{p}{;}
            \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
            \PY{c+c1}{// Concurrent execution of promises}
            \PY{k}{return} \PY{n+nx}{Promise}\PY{p}{.}\PY{n+nx}{all}\PY{p}{(}\PY{n+nx}{promises}\PY{p}{)}\PY{p}{;}
        \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{.}\PY{n+nx}{then}\PY{p}{(} \PY{p}{(}\PY{n+nx}{results}: \PY{k+kt}{Array}\PY{o}{\PYZlt{}}\PY{n+nx}{any}\PY{p}{[}\PY{p}{]}\PY{o}{\PYZgt{}}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
            \PY{c+c1}{// Reading first two elements of each file}
            \PY{n+nx}{results}\PY{p}{.}\PY{n+nx}{forEach}\PY{p}{(} \PY{p}{(}\PY{n+nx}{result}: \PY{k+kt}{Array}\PY{o}{\PYZlt{}}\PY{n+nx}{any}\PY{o}{\PYZgt{}}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+sb}{`}\PY{l+s+sb}{First two lines of file: }\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{result}\PY{p}{.}\PY{n+nx}{file}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{;} 
                \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{n+nx}{result}\PY{p}{.}\PY{n+nx}{data}\PY{p}{.}\PY{n+nx}{slice}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}\PY{p}{;} 
            \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
            \PY{c+c1}{// Async console for Jupyter}
            \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}done}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{(}\PY{p}{)}\PY{p}{;}
        \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{.}\PY{k}{catch}\PY{p}{(} \PY{p}{(}\PY{n+nx}{e}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{n+nx}{e}\PY{p}{)} \PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Parsing all the files, this may a while{\ldots}
First two lines of file: custom\_data/small\_aisles.csv
[ \{ aisle\_id: '1', aisle: 'prepared soups salads' \},
  \{ aisle\_id: '2', aisle: 'specialty cheeses' \} ]
First two lines of file: custom\_data/small\_departments.csv
[ \{ department\_id: '1', department: 'frozen' \},
  \{ department\_id: '2', department: 'other' \} ]
First two lines of file: custom\_data/small\_order\_products\_\_prior.csv
[ \{ order\_id: '2',
    product\_id: '33120',
    add\_to\_cart\_order: '1',
    reordered: '1' \},
  \{ order\_id: '2',
    product\_id: '28985',
    add\_to\_cart\_order: '2',
    reordered: '1' \} ]
First two lines of file: custom\_data/small\_order\_products\_\_train.csv
[ \{ order\_id: '1',
    product\_id: '1',
    add\_to\_cart\_order: '1',
    reordered: '1' \},
  \{ order\_id: '2',
    product\_id: '101',
    add\_to\_cart\_order: '2',
    reordered: '1' \} ]
First two lines of file: custom\_data/small\_orders.csv
[ \{ order\_id: '2539329',
    user\_id: '1',
    eval\_set: 'prior',
    order\_number: '1',
    order\_dow: '2',
    order\_hour\_of\_day: '08',
    days\_since\_prior\_order: '' \},
  \{ order\_id: '2398795',
    user\_id: '1',
    eval\_set: 'prior',
    order\_number: '2',
    order\_dow: '3',
    order\_hour\_of\_day: '07',
    days\_since\_prior\_order: '15.0' \} ]
First two lines of file: custom\_data/small\_products.csv
[ \{ product\_id: '1',
    product\_name: 'Chocolate Sandwich Cookies',
    aisle\_id: '61',
    department\_id: '19' \},
  \{ product\_id: '2',
    product\_name: 'All-Seasons Salt',
    aisle\_id: '104',
    department\_id: '13' \} ]

    \end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}3}]:} undefined
\end{Verbatim}
            
    File \texttt{aisles.csv} is structured as such; and contains the two
following rows:

\begin{longtable}[]{@{}ll@{}}
\toprule
aisle\_id & aisle\tabularnewline
\midrule
\endhead
1 & prepared soups salads\tabularnewline
2 & specialty cheeses\tabularnewline
\bottomrule
\end{longtable}

File \texttt{departments.csv} is structured as such; and contains the
two following rows:

\begin{longtable}[]{@{}ll@{}}
\toprule
department\_id & department\tabularnewline
\midrule
\endhead
1 & frozen\tabularnewline
2 & other\tabularnewline
\bottomrule
\end{longtable}

File \texttt{products.csv} is structured as such; and contains the two
following rows:

\begin{longtable}[]{@{}llll@{}}
\toprule
product\_id & product\_name & aisle\_id & department\_id\tabularnewline
\midrule
\endhead
1 & Chocolate Sandwich Cookies & 61 & 19\tabularnewline
2 & All-Seasons Salt & 104 & 13\tabularnewline
\bottomrule
\end{longtable}

Files \texttt{aisles.csv}, \texttt{departments.csv},
\texttt{products.csv} and all (trivially) contain information about the
aisles, products, and departments names respectivelly; which may not be
of any interet to us other than for enhanced visualisation. We'll thus
have to perform the proper \texttt{JOIN}s (a.k.a. \texttt{UNION})
between these tables and our future data / pattern collections when
needed.

File \texttt{orders.csv} is structured as such; and contains the two
following rows:

\begin{longtable}[]{@{}lllllll@{}}
\toprule
\begin{minipage}[b]{0.09\columnwidth}\raggedright
order\_id\strut
\end{minipage} & \begin{minipage}[b]{0.08\columnwidth}\raggedright
user\_id\strut
\end{minipage} & \begin{minipage}[b]{0.09\columnwidth}\raggedright
eval\_set\strut
\end{minipage} & \begin{minipage}[b]{0.12\columnwidth}\raggedright
order\_number\strut
\end{minipage} & \begin{minipage}[b]{0.09\columnwidth}\raggedright
order\_dow\strut
\end{minipage} & \begin{minipage}[b]{0.16\columnwidth}\raggedright
order\_hour\_of\_day\strut
\end{minipage} & \begin{minipage}[b]{0.19\columnwidth}\raggedright
days\_since\_prior\_order\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.09\columnwidth}\raggedright
2539329\strut
\end{minipage} & \begin{minipage}[t]{0.08\columnwidth}\raggedright
1\strut
\end{minipage} & \begin{minipage}[t]{0.09\columnwidth}\raggedright
prior\strut
\end{minipage} & \begin{minipage}[t]{0.12\columnwidth}\raggedright
1\strut
\end{minipage} & \begin{minipage}[t]{0.09\columnwidth}\raggedright
2\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright
08\strut
\end{minipage} & \begin{minipage}[t]{0.19\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.09\columnwidth}\raggedright
2398795\strut
\end{minipage} & \begin{minipage}[t]{0.08\columnwidth}\raggedright
1\strut
\end{minipage} & \begin{minipage}[t]{0.09\columnwidth}\raggedright
prior\strut
\end{minipage} & \begin{minipage}[t]{0.12\columnwidth}\raggedright
2\strut
\end{minipage} & \begin{minipage}[t]{0.09\columnwidth}\raggedright
3\strut
\end{minipage} & \begin{minipage}[t]{0.16\columnwidth}\raggedright
07\strut
\end{minipage} & \begin{minipage}[t]{0.19\columnwidth}\raggedright
15.0\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

File \texttt{orders.csv} is surely a bit more interresting, especially
having in mind \textbf{sequential pattern mining}, as it lists all the
orders, and contains information on \textbf{when} and \textbf{by who} it
has been placed.

Finally, files \texttt{order\_products\_\_train.csv} and
\texttt{order\_products\_\_prior.csv} contain the same, and most
valuable information in regard to pattern mining, as they contain
products ordered within each order: We will generate our transactions
from this file, grouping \texttt{product\_ids} by \texttt{order\_id}.

These files are structured as below:

\begin{longtable}[]{@{}llll@{}}
\toprule
order\_id & product\_id & add\_to\_cart\_order &
reordered\tabularnewline
\midrule
\endhead
1 & 49302 & 1 & 1\tabularnewline
1 & 11109 & 2 & 1\tabularnewline
\bottomrule
\end{longtable}

    \hypertarget{warming-up-first-statistics-over-the-dataset}{%
\subsection{Warming up: First statistics over the
dataset}\label{warming-up-first-statistics-over-the-dataset}}

Main perk of using TypeScript could be the language's proximity to the
DOM, for data visualisation. Upon this point, will be using
\texttt{D3.js} library, as well as \texttt{zingchart} the visualise our
data.

\texttt{D3.js} and \texttt{zingchart} are libraries allowing us to
create an interactive charts with smooth transitions and interaction. If
you're reading this of a \texttt{.pdf} version, please consider loading
this notebook in a browser (application is dockerized), as many graph
only make sense when being interacted with (as Chord Diagrams for
frequent itemset presentation for instance).

``Front-end'' dependencies will be loaded below.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{k+kd}{function} \PY{n+nx}{loadDependencies}\PY{p}{(}\PY{p}{)}\PY{o}{:} \PY{k}{void} \PY{p}{\PYZob{}}
            \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{.}\PY{n+nx}{html}\PY{p}{(}\PY{l+s+sb}{`}
        \PY{l+s+sb}{        \PYZlt{}script\PYZgt{}}
        \PY{l+s+sb}{            // Zingchart Library}
        \PY{l+s+sb}{            }\PY{l+s+sb}{\PYZdl{}}\PY{l+s+sb}{(\PYZsq{}head\PYZsq{}).append(\PYZsq{}\PYZlt{}script src=\PYZdq{}./node\PYZus{}modules/zingchart/client/zingchart.min.js\PYZdq{}\PYZgt{}\PYZsq{});}
        \PY{l+s+sb}{        \PYZlt{}/script\PYZgt{}}
        \PY{l+s+sb}{    }\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{;}
        \PY{p}{\PYZcb{}}
        
        \PY{n+nx}{loadDependencies}\PY{p}{(}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    We'll keep our first analysis of the data simple, and start by computing
some simple statistics over the dataset, on the number of orders,
products, products per order, etc. In addition to understanding more
about the data, this will also allow us to find some appropriate and
revelant criteria on which we could base (and reduce) our dataset for
extended itemset analysis; as well as giving us a first glance at
pattern dedundancy.

Keeping in mind that each row of the
\texttt{order\_products\_\_prior.csv} file is structured as stated
above; an interesting approach would be to regroup these objects by both
\texttt{order\_id} and \texttt{product\_id}, as it would allow us to
have a glance over the product distribution through the orders on the
first hand, as well as idea of each product's popularity on the other.

To do so, we need to transform the dataset consequently. Thus, let's
start by defining \texttt{ProductOrder} as the structure of the data
outputted by the \texttt{.csv} file parser. We will do the same for each
data structure of each file composing our dataset:
/**
 * Data structure we gather from CSV File.
 */
interface ProductOrder {
    order_id: string,
    product_id: string,
    add_to_cart_order: string,
    reordered: string
}
    From this point, as we focus on exploiting data from file
\texttt{order\_products\_\_prior.csv}, which contains more than 1
million records; and for the sake of memory usage, we'll try to work on
data streams as much as possible, rather than parsing
1-million-elements-cached \texttt{Arrays} when it comes to data
transformation. We'll thus be using Reactive Programming library
\texttt{RxJS} in that intent.

Reactive programming is nothing new as it only consists in programming
with asynchronous data streams, which languages like JS are basically
all about. \texttt{RxJS} yet provides us with an amazing and complete
approach -as well as a great toolbox of functions- to combine, create
and filter such streams easily.

    \hypertarget{grouping-by-orders}{%
\subsubsection{Grouping by orders}\label{grouping-by-orders}}

Let us define a function allowing us to group \texttt{ProductOrder}
objects by any key of the \texttt{ProductOrder} interface. We'll use in
that intent \texttt{RxJS}'s \texttt{groupBy} method, which basically
groups the items emitted by an \texttt{Observable} (a.k.a. stream; in
our case, the \texttt{ReadStream} of the considered file) according to a
specified criterion (in our case, either the \texttt{product\_id} or the
\texttt{order\_id}), and emits these grouped items as
\texttt{GroupedObservable}s, one \texttt{GroupedObservable} per group.

Let's start by defining a \texttt{Group\textless{}T\textgreater{}} as an
object containg an \texttt{id} (the grouping criterion basically), as
well as an \texttt{Array} of whatever item of type \texttt{T} we're
grouping. This will be one of many product of our function:
interface Group<T> {
    id: string,
    items: Array<T>
}
    We'll also forge ahead (keeping pattern mining in mind) by allowing this
method to \texttt{.map()} the \texttt{ProductOrder} objects to whatever
we want (its \texttt{id}, \texttt{product\_name}\ldots{}) depending on
our need.

Such a function is given below:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{k+kr}{import} \PY{p}{\PYZob{}} \PY{n+nx}{Observable} \PY{p}{\PYZcb{}} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}rxjs/Observable\PYZsq{}}\PY{p}{;}
        \PY{k+kr}{import} \PY{l+s+s1}{\PYZsq{}rxjs/add/operator/finally\PYZsq{}}\PY{p}{;}
        \PY{k+kr}{import} \PY{l+s+s1}{\PYZsq{}rxjs/add/operator/groupBy\PYZsq{}}\PY{p}{;}
        \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{RxNode} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}rx\PYZhy{}node\PYZsq{}}\PY{p}{;}
        
        \PY{c+cm}{/**}
        \PY{c+cm}{ * Function returns an Observable of `ProductOrder` group by a defined criterion. You may map the parsed `ProductOrder` to whatever value you want.}
        \PY{c+cm}{ */}
        \PY{k+kd}{function} \PY{n+nx}{\PYZus{}readAndGroupBy}\PY{o}{\PYZlt{}}\PY{n+nx}{T}\PY{o}{\PYZgt{}}\PY{p}{(} \PY{n+nx}{key}: \PY{k+kt}{keyof} \PY{n+nx}{ProductOrder}\PY{p}{,} \PY{n+nx}{map}\PY{o}{:} \PY{p}{(}\PY{n+nx}{val}: \PY{k+kt}{ProductOrder}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{T} \PY{p}{)}\PY{o}{:} \PY{n+nx}{Rx}\PY{p}{.}\PY{n+nx}{Observable}\PY{o}{\PYZlt{}}\PY{n+nx}{Group}\PY{o}{\PYZlt{}}\PY{n+nx}{T}\PY{o}{\PYZgt{}\PYZgt{}} \PY{p}{\PYZob{}}
            \PY{c+cm}{/**}
        \PY{c+cm}{     * \PYZsq{}csv\PYZhy{}parse\PYZsq{} Parser, columns options groups each row by column in an object.}
        \PY{c+cm}{     */}
            \PY{k+kd}{let} \PY{n+nx}{parser}: \PY{k+kt}{Parser} \PY{o}{=} \PY{k}{new} \PY{n+nx}{Parser}\PY{p}{(}\PY{p}{\PYZob{}}
                \PY{n+nx}{delimiter}\PY{o}{:} \PY{l+s+s1}{\PYZsq{},\PYZsq{}}\PY{p}{,}
                \PY{n+nx}{columns}: \PY{k+kt}{true}
            \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
        
            \PY{c+c1}{// Turning native stream into Observable}
            \PY{k}{return} \PY{n+nx}{RxNode}\PY{p}{.}\PY{n+nx}{fromStream}\PY{p}{(} \PY{n+nx}{fs}\PY{p}{.}\PY{n+nx}{createReadStream}\PY{p}{(}\PY{l+s+sb}{`}\PY{l+s+sb}{instacart\PYZus{}basket\PYZus{}data/order\PYZus{}products\PYZus{}\PYZus{}train.csv}\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{.}\PY{n+nx}{pipe}\PY{p}{(}\PY{n+nx}{parser}\PY{p}{)} \PY{p}{)}
                \PY{c+c1}{// Grouping objects by order}
                \PY{p}{.}\PY{n+nx}{groupBy}\PY{p}{(} \PY{p}{(}\PY{n+nx}{data}: \PY{k+kt}{ProductOrder}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{data}\PY{p}{[}\PY{n+nx}{key}\PY{p}{]} \PY{p}{)}
                \PY{c+c1}{// At this point, we basically have an Observable by group. Thus we need to flatten that.}
                \PY{p}{.}\PY{n+nx}{flatMap}\PY{p}{(} \PY{p}{(}\PY{n+nx}{group}: \PY{k+kt}{Rx.GroupedObservable}\PY{o}{\PYZlt{}}\PY{k+kt}{string}\PY{p}{,} \PY{n+nx}{ProductOrder}\PY{o}{\PYZgt{}}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                    \PY{k}{return} \PY{n+nx}{group}
                        \PY{c+c1}{// Formatting the data}
                        \PY{p}{.}\PY{n+nx}{map}\PY{p}{(}\PY{n+nx}{map}\PY{p}{)}
                        \PY{c+c1}{// And flattening the Observable array.}
                        \PY{p}{.}\PY{n+nx}{reduce}\PY{p}{(} \PY{p}{(}\PY{n+nx}{concat}: \PY{k+kt}{Group}\PY{o}{\PYZlt{}}\PY{n+nx}{T}\PY{o}{\PYZgt{}}\PY{p}{,} \PY{n+nx}{current}: \PY{k+kt}{T}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                            \PY{n+nx}{concat}\PY{p}{.}\PY{n+nx}{items}\PY{p}{.}\PY{n+nx}{push}\PY{p}{(}\PY{n+nx}{current}\PY{p}{)}\PY{p}{;}
                            \PY{k}{return} \PY{n+nx}{concat}\PY{p}{;}
                        \PY{p}{\PYZcb{}}\PY{p}{,} \PY{p}{\PYZob{}}
                            \PY{n+nx}{id}: \PY{k+kt}{group.key}\PY{p}{,}
                            \PY{n+nx}{items}\PY{o}{:} \PY{p}{[}\PY{p}{]}
                        \PY{p}{\PYZcb{}}\PY{p}{)}
                \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
        \PY{p}{\PYZcb{}}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}4}]:} \{\}
\end{Verbatim}
            
    Let us group the \texttt{ProductOrder} by their \texttt{order\_id}.
\texttt{ProductOrders} will be caracterized by their
\texttt{product\_id} (We'll thus trivially have an list of Orders (or
itemsets), as \texttt{Arrays} of \texttt{product\_id}s).

Function above will return us with all the processed groups. We'll
compute some basic statistics on these from there, such as: - The number
of orders (number of groups); - The minimum number of product in an
order (minimum of arrays length); - The maximum number of product in an
order (maximum of arrays length); - The average product number per order
(average array length); - The number of records in the
\texttt{order\_products\_\_prior.csv} file (sum of arrays length);

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{k+kd}{function} \PY{n+nx}{statsOnOrders}\PY{p}{(}\PY{p}{)}\PY{o}{:} \PY{k}{void} \PY{p}{\PYZob{}}
            \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}async}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}} \PY{o}{=} \PY{k+kc}{true}\PY{p}{;}
            \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Gathering data, this might take a while...\PYZsq{}}\PY{p}{)}\PY{p}{;}
            
            \PY{c+cm}{/**}
        \PY{c+cm}{     * All the groups.}
        \PY{c+cm}{     */}
            \PY{k+kd}{let} \PY{n+nx}{groups}: \PY{k+kt}{Array}\PY{o}{\PYZlt{}}\PY{n+nx}{Group}\PY{o}{\PYZlt{}}\PY{k+kt}{string}\PY{o}{\PYZgt{}\PYZgt{}} \PY{o}{=} \PY{p}{[}\PY{p}{]}\PY{p}{;}
        
            \PY{c+cm}{/**}
        \PY{c+cm}{     * Product per order for Chart}
        \PY{c+cm}{     */}
            \PY{k+kd}{let} \PY{n+nx}{productsPerOrder}: \PY{k+kt}{Array}\PY{o}{\PYZlt{}}\PY{k+kt}{number}\PY{o}{\PYZgt{}} \PY{o}{=} \PY{p}{[}\PY{p}{]}\PY{p}{;}
        
            \PY{k+kd}{let} \PY{n+nx}{stats}: \PY{k+kt}{any} \PY{o}{=} \PY{p}{\PYZob{}}
                \PY{n+nx}{max}: \PY{k+kt}{0}\PY{p}{,}
                \PY{n+nx}{min}: \PY{k+kt}{Infinity}\PY{p}{,}
                \PY{n+nx}{sum}: \PY{k+kt}{0}
            \PY{p}{\PYZcb{}}
        
            \PY{c+cm}{/**}
        \PY{c+cm}{     * Reads the file and groups `ProductOrders as intended`}
        \PY{c+cm}{     */}
        
            \PY{n+nx}{\PYZus{}readAndGroupBy}\PY{o}{\PYZlt{}}\PY{k+kt}{string}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}order\PYZus{}id\PYZsq{}}\PY{p}{,} \PY{p}{(}\PY{n+nx}{productOrder}: \PY{k+kt}{ProductOrder}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{productOrder}\PY{p}{.}\PY{n+nx}{product\PYZus{}id} \PY{p}{)}
                \PY{c+c1}{// Once all groups are loaded, displaying them.}
                \PY{p}{.}\PY{k}{finally}\PY{p}{(} \PY{p}{(}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                    \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+sb}{`}\PY{l+s+sb}{Maximum number of ProductOrders: }\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{stats}\PY{p}{.}\PY{n+nx}{max}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{;}
                    \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+sb}{`}\PY{l+s+sb}{Minimum number of ProductOrders: }\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{stats}\PY{p}{.}\PY{n+nx}{min}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{;}
                    \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+sb}{`}\PY{l+s+sb}{Average number of ProductOrders: }\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{stats}\PY{p}{.}\PY{n+nx}{sum} \PY{o}{/} \PY{n+nx}{groups}\PY{p}{.}\PY{n+nx}{length}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{;}
                    \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+sb}{`}\PY{l+s+sb}{Total number of ProductOrders: }\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{stats}\PY{p}{.}\PY{n+nx}{sum}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{;}
                    \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+sb}{`}\PY{l+s+sb}{Number of itemsets: }\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{groups}\PY{p}{.}\PY{n+nx}{length}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{;}
                    
                    \PY{k+kd}{let} \PY{n+nx}{chartOptions}: \PY{k+kt}{string} \PY{o}{=}\PY{err}{ }\PY{n+nx}{JSON}\PY{p}{.}\PY{n+nx}{stringify}\PY{p}{(}\PY{p}{\PYZob{}}
                        \PY{n+nx}{id}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}productPerOrderChart\PYZsq{}}\PY{p}{,}
                        \PY{n+nx}{data}\PY{o}{:} \PY{p}{\PYZob{}}
                            \PY{n+nx}{type}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}bar\PYZsq{}}\PY{p}{,}
                            \PY{n+nx}{title}\PY{o}{:} \PY{p}{\PYZob{}}
                                \PY{n+nx}{text}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}Product per order sorted ascendingly\PYZsq{}}
                            \PY{p}{\PYZcb{}}\PY{p}{,}
                            \PY{n+nx}{scaleY}\PY{o}{:} \PY{p}{\PYZob{}}
                                \PY{n+nx}{label}\PY{o}{:} \PY{p}{\PYZob{}}
                                  \PY{n+nx}{text}\PY{o}{:} \PY{l+s+s2}{\PYZdq{}Number of products\PYZdq{}}
                                \PY{p}{\PYZcb{}}\PY{p}{,}
                                \PY{n+nx}{item}\PY{o}{:} \PY{p}{\PYZob{}}
                                  \PY{n+nx}{fontSize}: \PY{k+kt}{10}
                                \PY{p}{\PYZcb{}}
                            \PY{p}{\PYZcb{}}\PY{p}{,}
                            \PY{n+nx}{scaleX}\PY{o}{:} \PY{p}{\PYZob{}}
                                \PY{n+nx}{label}\PY{o}{:} \PY{p}{\PYZob{}}
                                  \PY{n+nx}{text}\PY{o}{:} \PY{l+s+s2}{\PYZdq{}Order id\PYZdq{}}
                                \PY{p}{\PYZcb{}}\PY{p}{,}
                                \PY{n+nx}{item}\PY{o}{:} \PY{p}{\PYZob{}}
                                  \PY{n+nx}{fontSize}: \PY{k+kt}{10}
                                \PY{p}{\PYZcb{}}
                            \PY{p}{\PYZcb{}}\PY{p}{,}
                            \PY{n+nx}{series}\PY{o}{:} \PY{p}{[}\PY{p}{\PYZob{}} \PY{n+nx}{values}: \PY{k+kt}{productsPerOrder.sort}\PY{p}{(} \PY{p}{(}\PY{n+nx}{a}: \PY{k+kt}{number}\PY{p}{,} \PY{n+nx}{b}: \PY{k+kt}{number}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{a} \PY{o}{\PYZhy{}} \PY{n+nx}{b}\PY{p}{)} \PY{p}{\PYZcb{}}\PY{p}{]}
                        \PY{p}{\PYZcb{}}
                    \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
                    
                    \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{.}\PY{n+nx}{html}\PY{p}{(}\PY{l+s+sb}{`}
        \PY{l+s+sb}{                \PYZlt{}div id=\PYZdq{}productPerOrderChart\PYZdq{}\PYZgt{}\PYZlt{}/div\PYZgt{}}
        \PY{l+s+sb}{                \PYZlt{}script\PYZgt{}}
        \PY{l+s+sb}{                  zingchart.render(}\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{chartOptions}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{);}
        \PY{l+s+sb}{                \PYZlt{}/script\PYZgt{}}
        \PY{l+s+sb}{            }\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{;}
                
                    \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}done}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{(}\PY{p}{)}\PY{p}{;}
                \PY{p}{\PYZcb{}}\PY{p}{)}
                \PY{c+c1}{// Note that this behaviour (induced by the flatMap of readAndGroupBy) makes everything pretty much blocking again.}
                \PY{p}{.}\PY{n+nx}{subscribe}\PY{p}{(} \PY{p}{(}\PY{n+nx}{group}: \PY{k+kt}{Group}\PY{o}{\PYZlt{}}\PY{k+kt}{string}\PY{o}{\PYZgt{}}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                    \PY{c+c1}{// Computing some basic stats on the fly}
                    \PY{n+nx}{stats}\PY{p}{.}\PY{n+nx}{max} \PY{o}{=} \PY{n+nb}{Math}\PY{p}{.}\PY{n+nx}{max}\PY{p}{(}\PY{n+nx}{group}\PY{p}{.}\PY{n+nx}{items}\PY{p}{.}\PY{n+nx}{length}\PY{p}{,} \PY{n+nx}{stats}\PY{p}{.}\PY{n+nx}{max}\PY{p}{)}\PY{p}{;}
                    \PY{n+nx}{stats}\PY{p}{.}\PY{n+nx}{min} \PY{o}{=} \PY{n+nb}{Math}\PY{p}{.}\PY{n+nx}{min}\PY{p}{(}\PY{n+nx}{group}\PY{p}{.}\PY{n+nx}{items}\PY{p}{.}\PY{n+nx}{length}\PY{p}{,} \PY{n+nx}{stats}\PY{p}{.}\PY{n+nx}{min}\PY{p}{)}\PY{p}{;}
                    \PY{n+nx}{stats}\PY{p}{.}\PY{n+nx}{sum} \PY{o}{+=} \PY{n+nx}{group}\PY{p}{.}\PY{n+nx}{items}\PY{p}{.}\PY{n+nx}{length}\PY{p}{;}
        
                    \PY{c+c1}{// Pushing group to groups.}
                    \PY{n+nx}{groups}\PY{p}{.}\PY{n+nx}{push}\PY{p}{(}\PY{n+nx}{group}\PY{p}{)}\PY{p}{;}
                    
                    \PY{c+c1}{// Chart display data}
                    \PY{n+nx}{productsPerOrder}\PY{p}{.}\PY{n+nx}{push}\PY{p}{(}\PY{n+nx}{group}\PY{p}{.}\PY{n+nx}{items}\PY{p}{.}\PY{n+nx}{length}\PY{p}{)}\PY{p}{;}
                \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
        \PY{p}{\PYZcb{}}
        
        \PY{n+nx}{statsOnOrders}\PY{p}{(}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Gathering data, this might take a while{\ldots}
Maximum number of ProductOrders: 80
Minimum number of ProductOrders: 1
Average number of ProductOrders: 10.552759338155157
Total number of ProductOrders: 1384617
Number of itemsets: 131209

    \end{Verbatim}

    Grouping the records by their \texttt{order\_id} enlights us of the
following information:

\begin{longtable}[]{@{}llllll@{}}
\toprule
\begin{minipage}[b]{0.02\columnwidth}\raggedright
Number of orders\strut
\end{minipage} & \begin{minipage}[b]{0.02\columnwidth}\raggedright
~Minimum product number per order\strut
\end{minipage} & \begin{minipage}[b]{0.02\columnwidth}\raggedright
~Maximum product number per order\strut
\end{minipage} & \begin{minipage}[b]{0.02\columnwidth}\raggedright
~Average product number per order\strut
\end{minipage} & \begin{minipage}[b]{0.02\columnwidth}\raggedright
~Total number of records~\strut
\end{minipage} & \begin{minipage}[b]{0.02\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.02\columnwidth}\raggedright
131,209\strut
\end{minipage} & \begin{minipage}[t]{0.02\columnwidth}\raggedright
~1\strut
\end{minipage} & \begin{minipage}[t]{0.02\columnwidth}\raggedright
~80\strut
\end{minipage} & \begin{minipage}[t]{0.02\columnwidth}\raggedright
10.6\strut
\end{minipage} & \begin{minipage}[t]{0.02\columnwidth}\raggedright
~1,384,617\strut
\end{minipage} & \begin{minipage}[t]{0.02\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Eventhough the maximum number of product per order is 80, the graph
above shows that approximatly 85\% of all the orders only contains
between 1 and 20 orders.

    \hypertarget{grouping-by-product}{%
\subsubsection{Grouping by product}\label{grouping-by-product}}

Creating itemsets (\texttt{Groups}) of Orders, based on the
\texttt{product\_id} of \texttt{ProductOrders} may also be of interest
to us, as it allow us ``feel'' a product ``popularity'' by counting the
number of orders it appears in. This is a pretty good deal in regards to
pattern mining, as: - a ``frequent'' product will be more likely to
appear in frequent itemsets; - its number of appearance in the
collection is, by definition, the maximum support over the dataset.
Considering a product A being the most popular in a dataset such as
ours, the itemset \texttt{\{\ A\ \}}~will trivially be the absolute,
most frequent itemset to be find in the entire dataset; - if a product
is too frequent, it may be of interest to ignore it, as the itemsets to
be find may not be revealant enough.

    Code is basically the same as before, thus won't be included in the
notebook. Sources are however still available and results may be parsed
from \texttt{custom\_data/product\_id\_\_order\_number.csv}.

Grouping the records by their \texttt{product\_id} gives us the
following results:

\begin{longtable}[]{@{}llllll@{}}
\toprule
\begin{minipage}[b]{0.02\columnwidth}\raggedright
Number of products\strut
\end{minipage} & \begin{minipage}[b]{0.02\columnwidth}\raggedright
~Minimum order number per product\strut
\end{minipage} & \begin{minipage}[b]{0.02\columnwidth}\raggedright
~Maximum order number per product\strut
\end{minipage} & \begin{minipage}[b]{0.02\columnwidth}\raggedright
~Average order number per product\strut
\end{minipage} & \begin{minipage}[b]{0.02\columnwidth}\raggedright
~Total number of records~\strut
\end{minipage} & \begin{minipage}[b]{0.02\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.02\columnwidth}\raggedright
391,23\strut
\end{minipage} & \begin{minipage}[t]{0.02\columnwidth}\raggedright
~1\strut
\end{minipage} & \begin{minipage}[t]{0.02\columnwidth}\raggedright
~18,726\strut
\end{minipage} & \begin{minipage}[t]{0.02\columnwidth}\raggedright
35.39\strut
\end{minipage} & \begin{minipage}[t]{0.02\columnwidth}\raggedright
~1,384,617\strut
\end{minipage} & \begin{minipage}[t]{0.02\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

Let us determine the most popular products, by joining the retrieved
data with table \texttt{products.csv}:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{CSVParser} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/class/csv\PYZhy{}parser.class.js\PYZsq{}}\PY{p}{;}
        \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{join} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/function/join.function.js\PYZsq{}}
        
        \PY{k+kd}{function} \PY{n+nx}{joinResultsAndShowPopular}\PY{p}{(}\PY{p}{)}\PY{o}{:} \PY{k}{void} \PY{p}{\PYZob{}}
            \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}async}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}} \PY{o}{=} \PY{k+kc}{true}\PY{p}{;}
            \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Gathering data, this might take a while...\PYZsq{}}\PY{p}{)}\PY{p}{;}
        
            \PY{c+c1}{// Data to display.}
            \PY{k+kd}{let} \PY{n+nx}{chartData}: \PY{k+kt}{Array}\PY{o}{\PYZlt{}}\PY{n+nx}{any}\PY{o}{\PYZgt{}} \PY{o}{=} \PY{p}{[}\PY{p}{]}\PY{p}{;}
        
            \PY{c+c1}{// Loading the \PYZsq{}product.csv\PYZsq{} table.}
            \PY{k}{new} \PY{n+nx}{CSVParser}\PY{p}{.}\PY{n+nx}{CSVParser}\PY{o}{\PYZlt{}}\PY{n+nx}{Product}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+s+sb}{`}\PY{l+s+sb}{instacart\PYZus{}basket\PYZus{}data/products.csv}\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{.}\PY{n+nx}{loadAll}\PY{p}{(}\PY{p}{)}
                \PY{p}{.}\PY{n+nx}{then}\PY{p}{(} \PY{p}{(}\PY{n+nx}{products}: \PY{k+kt}{Product}\PY{p}{[}\PY{p}{]}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                    \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Finished loading products\PYZsq{}}\PY{p}{)}\PY{p}{;}
        
                    \PY{c+c1}{// Now generating group of items based on the product\PYZus{}id}
                    \PY{k}{new} \PY{n+nx}{CSVParser}\PY{p}{.}\PY{n+nx}{CSVParser}\PY{o}{\PYZlt{}}\PY{n+nx}{ProductOrder}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+s+sb}{`}\PY{l+s+sb}{instacart\PYZus{}basket\PYZus{}data/order\PYZus{}products\PYZus{}\PYZus{}train.csv}\PY{l+s+sb}{`}\PY{p}{)}
                        \PY{c+c1}{// Grouping items by product\PYZus{}id, and mapping every item composing these itemsets to their order\PYZus{}id.}
                        \PY{p}{.}\PY{n+nx}{generateItemsets}\PY{o}{\PYZlt{}}\PY{k+kt}{string}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}product\PYZus{}id\PYZsq{}}\PY{p}{,} \PY{p}{(}\PY{n+nx}{productOrder}: \PY{k+kt}{ProductOrder}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{productOrder}\PY{p}{.}\PY{n+nx}{order\PYZus{}id} \PY{p}{)}
                        \PY{c+c1}{// Once execution is complete, creating chart.}
                        \PY{p}{.}\PY{k}{finally}\PY{p}{(} \PY{p}{(}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                            \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Most popular products :\PYZsq{}}\PY{p}{)}\PY{p}{;}
        
                            \PY{n+nx}{chartData} \PY{o}{=} \PY{n+nx}{chartData}
                                \PY{c+c1}{// Sorting desc.}
                                \PY{p}{.}\PY{n+nx}{sort}\PY{p}{(} \PY{p}{(}\PY{n+nx}{a}: \PY{k+kt}{any}\PY{p}{,} \PY{n+nx}{b}: \PY{k+kt}{any}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{b}\PY{p}{.}\PY{k+kt}{number} \PY{o}{\PYZhy{}} \PY{n+nx}{a}\PY{p}{.}\PY{k+kt}{number} \PY{p}{)}
                                \PY{c+c1}{// Keeping 10 best products}
                                \PY{p}{.}\PY{n+nx}{splice}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{;}
                        
                            \PY{k+kd}{let} \PY{n+nx}{chartOptions}: \PY{k+kt}{string} \PY{o}{=}\PY{err}{ }\PY{n+nx}{JSON}\PY{p}{.}\PY{n+nx}{stringify}\PY{p}{(}\PY{p}{\PYZob{}}
                                \PY{n+nx}{id}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}popularProductsChart\PYZsq{}}\PY{p}{,}
                                \PY{n+nx}{data}\PY{o}{:} \PY{p}{\PYZob{}}
                                    \PY{n+nx}{type}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}bar\PYZsq{}}\PY{p}{,}
                                    \PY{n+nx}{title}\PY{o}{:} \PY{p}{\PYZob{}}
                                        \PY{n+nx}{text}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}The 10 most popular products (number of orders)\PYZsq{}}
                                    \PY{p}{\PYZcb{}}\PY{p}{,}
                                    \PY{n+nx}{scaleY}\PY{o}{:} \PY{p}{\PYZob{}}
                                        \PY{n+nx}{label}\PY{o}{:} \PY{p}{\PYZob{}}
                                          \PY{n+nx}{text}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}Times ordered\PYZsq{}}
                                        \PY{p}{\PYZcb{}}\PY{p}{,}
                                        \PY{n+nx}{item}\PY{o}{:} \PY{p}{\PYZob{}}
                                          \PY{n+nx}{fontSize}: \PY{k+kt}{10}
                                        \PY{p}{\PYZcb{}}
                                    \PY{p}{\PYZcb{}}\PY{p}{,}
                                    \PY{n+nx}{scaleX}\PY{o}{:}\PY{p}{\PYZob{}}
                                        \PY{n+nx}{values}: \PY{k+kt}{chartData.map}\PY{p}{(} \PY{p}{(}\PY{n+nx}{product}: \PY{k+kt}{any}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{product}\PY{p}{.}\PY{n+nx}{name} \PY{p}{)}\PY{p}{,}
                                        \PY{n+nx}{item}\PY{o}{:} \PY{p}{\PYZob{}}  
                                            \PY{l+s+s1}{\PYZsq{}font\PYZhy{}size\PYZsq{}}\PY{o}{:}\PY{l+s+s1}{\PYZsq{}6px\PYZsq{}}  
                                        \PY{p}{\PYZcb{}}  
                                    \PY{p}{\PYZcb{}}\PY{p}{,}
                                    \PY{n+nx}{series}\PY{o}{:} \PY{p}{[}\PY{p}{\PYZob{}} \PY{n+nx}{values}: \PY{k+kt}{chartData.map}\PY{p}{(} \PY{p}{(}\PY{n+nx}{product}: \PY{k+kt}{any}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{product}\PY{p}{.}\PY{k+kt}{number} \PY{p}{)} \PY{p}{\PYZcb{}}\PY{p}{]}
                                \PY{p}{\PYZcb{}}
                            \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
                        
                            \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{.}\PY{n+nx}{html}\PY{p}{(}\PY{l+s+sb}{`}
        \PY{l+s+sb}{                        \PYZlt{}div id=\PYZdq{}popularProductsChart\PYZdq{}\PYZgt{}\PYZlt{}/div\PYZgt{}}
        \PY{l+s+sb}{                        \PYZlt{}script\PYZgt{}}
        \PY{l+s+sb}{                          zingchart.render(}\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{chartOptions}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{);}
        \PY{l+s+sb}{                        \PYZlt{}/script\PYZgt{}}
        \PY{l+s+sb}{                    }\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{;}
        
                            \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}done}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{(}\PY{p}{)}\PY{p}{;}
        
                        \PY{p}{\PYZcb{}}\PY{p}{)}
                        \PY{c+c1}{// Once a group is ready, pushing chart data to the proper array.}
                        \PY{p}{.}\PY{n+nx}{subscribe}\PY{p}{(} \PY{p}{(}\PY{n+nx}{group}: \PY{k+kt}{Group}\PY{o}{\PYZlt{}}\PY{n+nx}{ProductOrder}\PY{p}{,}\PY{k+kt}{string}\PY{o}{\PYZgt{}}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                            \PY{n+nx}{chartData}\PY{p}{.}\PY{n+nx}{push}\PY{p}{(}\PY{p}{\PYZob{}}
                                \PY{n+nx}{name}: \PY{k+kt}{join.join}\PY{o}{\PYZlt{}}\PY{n+nx}{Product}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{n+nx}{products}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}product\PYZus{}id\PYZsq{}}\PY{p}{,} \PY{n+nx}{group}\PY{p}{.}\PY{n+nx}{id}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}product\PYZus{}name\PYZsq{}}\PY{p}{)}\PY{p}{,}
                                \PY{k+kt}{number}\PY{o}{:} \PY{n+nx}{group}\PY{p}{.}\PY{n+nx}{items}\PY{p}{.}\PY{n+nx}{length}
                            \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
                        \PY{p}{\PYZcb{}}\PY{p}{)}
                \PY{p}{\PYZcb{}}\PY{p}{,} \PY{p}{(}\PY{n+nx}{e}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}\PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
        \PY{p}{\PYZcb{}}
        
        \PY{n+nx}{joinResultsAndShowPopular}\PY{p}{(}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Gathering data, this might take a while{\ldots}
Finished loading products
Most popular products :

    \end{Verbatim}

    Graph above show the 10 most popular products, based on the number of
time they've been ordered; \textbf{Banana} being the most popular
product, with 18,726 orders. From a pattern miner point of view, these
products have more chance to be part of multiples itemsets, being that
all singleton-itemsets of each of these products are the most frequents.

We can also see that many popular items fall into the same category of
product (\texttt{Banana} \& \texttt{Bag\ of\ Organic\ Bananas} /
\texttt{Organic\ Avocado} \& \texttt{Organic\ Hass\ Avocado}). If we had
some time, regrouping these products would have been a good idea, as
more interesting patterns may appear: Nobody would ever buy both
Strawberries and Organic Strawberries in the same transaction, yet
itemsets \texttt{\textless{}\{Banana},
\texttt{Strawberries\}\textgreater{}} and
\texttt{\textless{}\{Bag\ of\ Organic\ Bananas},
\texttt{Rasberries\}\textgreater{}} \textbf{could} be considered as one
(if you don't have interest in your consumer \texttt{Organic} habits).

Grouping products per aisle (and exploring aisle-to-aisle itemsets) may
be a less-time consuming alternative if the need of reducing the dataset
becomes apparent: Results would appear as ``Someone buying fruits have
more chance buying vegetables''; though we obviously loose information
on the products bought.

In the meantime, It is worth noticing that \textbf{46 products}
including \texttt{100\%\ Black\ Cherry\ \&\ Concord\ Grape\ Juice},
\texttt{Breaded\ Popcorn\ Turkey\ Dogs} or \texttt{Lip\ Balm}, are the
least popular with only 1 order. Filtering less popular products may
also be a solution to reducing the dataset; yet I guess this would not
change a lot as these elements would still pruned pretty fast by
data-mining algorithms when mining for patterns.

    \hypertarget{frequent-item-sets}{%
\subsection{Frequent item sets}\label{frequent-item-sets}}

Knowing a little bit more about our data, we'll now move to mine and
gather \textbf{frequent} itemsets from our training dataset
(\texttt{order\_products\_train.csv}). In other words, we will focus on
finding regularities in the shopping behavior of customers, based on
what \texttt{product} orders (a.k.a. transactions) are composed of.

\hypertarget{vocabulary}{%
\subsubsection{Vocabulary}\label{vocabulary}}

Let us define some basic vocabulary we will be tremendously be using: -
Let I be a set of items. An itemset is a subset of I. - Let D be a
transaction database such that each transaction is an itemset. -
Frequency of an itemset is the number of transactions including the
itemset. - For a given support, an itemset is said to be frequent if its
frequency is no less than the support.

\hypertarget{spmf-open-source-library}{%
\subsubsection{SPMF Open-Source
Library}\label{spmf-open-source-library}}

Many (if not all) algorithms tested upon this point will be
implementations from SPMF library
(http://www.philippe-fournier-viger.com/spmf/); an open-source data
mining mining library written in Java, specialized in pattern mining.

A NodeJS JS/TypeScript wrapper, \texttt{class\ SPMF} for SPMF (spawning
Java commands) has been written in order to execute these, while still
exploiting the results with Typescript. Sources may be find in file
\texttt{./src/class/spmf.ts}. Examples of its use are shown below.

\hypertarget{apriori}{%
\subsubsection{Apriori}\label{apriori}}

Keeping our goal in mind, we'll start by using the \textbf{Apriori
Algorithm}. The object of this algorithm is to identify association
between different sets of data, and to find out patterns in data using a
``bottom up approach'', as frequent subsets are extended one item at a
time; and is based on a property called the anti-monotone property: It
states that if an item set is not frequent, then none of its supersets
can be frequent. As a result, the list of potential frequent itemset
gets smaller as mining progresses {[}1{]}.

Though the Apriori Algorithm is easy to implement and understand, it is
far from being performant the reasons stated above.

\hypertarget{dataset-formatting}{%
\paragraph{Dataset formatting}\label{dataset-formatting}}

Upon this point we will be using SPMF library's Java implementation of
Apriori (through command lines), in order to mine frequent item sets
from our dataset. This implementation needs the input data to be
formatted as such:

\begin{itemize}
\tightlist
\item
  An item is represented by a positive integer.
\item
  A transaction is a line in the file.
\item
  In each line (transaction), items are separated by a single space.
\item
  It is assumed that all items within a same transaction (line) are
  sorted according to a total order and that no item can appear twice
  within the same line.
\end{itemize}

For example, an input file is defined as follows:

\begin{verbatim}
1 2 5
2 7
\end{verbatim}

Transforming this dataset into this format is pretty straightforward
using the code we already wrote previously (same code, but encapsulated
in a \texttt{CSVParser} class). To save us some time, already formatted
data will be available to parse (file
\texttt{custom\_data/formatted-itemsets.csv}). Here is an example of
\texttt{CSVParser} though, running on a custom 6-line dataset:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{c+c1}{// Our custom parser class, looks like Jupyter/iTypescript doesn\PYZsq{}t like ES6 imports of custom Typescript classes.}
        \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{CSVParser} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/class/csv\PYZhy{}parser.class.js\PYZsq{}}\PY{p}{;}
        \PY{k+kr}{import} \PY{p}{\PYZob{}} \PY{n+nx}{ProductOrder} \PY{p}{\PYZcb{}} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./src/interface/product\PYZhy{}order.interface\PYZsq{}}\PY{p}{;}
        \PY{k+kr}{import} \PY{p}{\PYZob{}} \PY{n+nx}{Group} \PY{p}{\PYZcb{}} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./src/interface/group.interface\PYZsq{}}\PY{p}{;}
        
        \PY{k+kd}{function} \PY{n+nx}{formatData}\PY{p}{(}\PY{p}{)}\PY{o}{:} \PY{k}{void} \PY{p}{\PYZob{}}
            \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}async}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}} \PY{o}{=} \PY{k+kc}{true}\PY{p}{;}
            \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Generating transactions, this might take a while...\PYZsq{}}\PY{p}{)}\PY{p}{;}
            
            \PY{k+kd}{let} \PY{n+nx}{groups}: \PY{k+kt}{Group}\PY{o}{\PYZlt{}}\PY{n+nx}{ProductOrder}\PY{p}{,}\PY{k+kt}{number}\PY{o}{\PYZgt{}}\PY{p}{[}\PY{p}{]} \PY{o}{=} \PY{p}{[}\PY{p}{]}\PY{p}{;}
        
            \PY{k}{new} \PY{n+nx}{CSVParser}\PY{p}{.}\PY{n+nx}{CSVParser}\PY{o}{\PYZlt{}}\PY{n+nx}{ProductOrder}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+s+sb}{`}\PY{l+s+sb}{custom\PYZus{}data/small\PYZus{}order\PYZus{}products\PYZus{}\PYZus{}train.csv}\PY{l+s+sb}{`}\PY{p}{)}
                \PY{c+c1}{// Grouping items by order\PYZus{}id, and mapping every item composing these itemsets to their product\PYZus{}id.}
                \PY{p}{.}\PY{n+nx}{generateItemsets}\PY{o}{\PYZlt{}}\PY{k+kt}{number}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}order\PYZus{}id\PYZsq{}}\PY{p}{,} \PY{p}{(}\PY{n+nx}{productOrder}: \PY{k+kt}{ProductOrder}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nb}{Number}\PY{p}{.}\PY{n+nb}{parseInt}\PY{p}{(}\PY{n+nx}{productOrder}\PY{p}{.}\PY{n+nx}{product\PYZus{}id}\PY{p}{)}\PY{p}{)}
                \PY{c+c1}{// Once execution is complete, writing the formatted dataset into a proper file.}
                \PY{p}{.}\PY{k}{finally}\PY{p}{(} \PY{p}{(}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                    \PY{c+c1}{// Writing number of product per order\PYZus{}id in a new file : The array of already formatted rows is joined by a return carriage character.}
                    \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Example of output:\PYZsq{}}\PY{p}{)}\PY{p}{;}
                    \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{n+nx}{groups}\PY{p}{.}\PY{n+nx}{join}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}\PYZbs{}r\PYZbs{}n\PYZsq{}}\PY{p}{)}\PY{p}{)}\PY{p}{;}
                    \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}done}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{(}\PY{p}{)}\PY{p}{;}
                \PY{p}{\PYZcb{}}\PY{p}{)}
                \PY{c+c1}{// On group reception, formatting the items composing is as a ROW (joined by plain space character), and pushing it the output array.}
                \PY{p}{.}\PY{n+nx}{subscribe}\PY{p}{(}\PY{p}{(}\PY{n+nx}{group}: \PY{k+kt}{Group}\PY{o}{\PYZlt{}}\PY{n+nx}{ProductOrder}\PY{p}{,}\PY{k+kt}{number}\PY{o}{\PYZgt{}}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{groups}\PY{p}{.}\PY{n+nx}{push}\PY{p}{(}\PY{n+nx}{group}\PY{p}{.}\PY{n+nx}{items}\PY{p}{.}\PY{n+nx}{sort}\PY{p}{(} \PY{p}{(}\PY{n+nx}{a}: \PY{k+kt}{number}\PY{p}{,} \PY{n+nx}{b}: \PY{k+kt}{number}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{a} \PY{o}{\PYZhy{}} \PY{n+nx}{b} \PY{p}{)}\PY{p}{.}\PY{n+nx}{join}\PY{p}{(}\PY{l+s+s1}{\PYZsq{} \PYZsq{}}\PY{p}{)}\PY{p}{)} \PY{p}{)}
        \PY{p}{\PYZcb{}}
        
        \PY{n+nx}{formatData}\PY{p}{(}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Generating transactions, this might take a while{\ldots}
Example of output:
1
101 1002
10 100 2000

    \end{Verbatim}

    \hypertarget{parsing-the-results}{%
\paragraph{Parsing the results}\label{parsing-the-results}}

This Apriori implementation enlights us with multiple information other
than the frequent itemsets themselves, as it outputs multiple results
through both \texttt{stdout}, including: - The number of candidates; -
The maximum size of candidates the algorithm stopped at; - The frequent
itemsets count; - Maximum memory usage; - Total execution time.

Mined frequent itemsets may be find in the specified output file,
formatted as below:

\begin{verbatim}
...A #SUP: B

-- EXAMPLES OF OUTPUT --
49628 #SUP: 186
49683 #SUP: 2413
13176 21137  #SUP: 164
13176 21903  #SUP: 175
\end{verbatim}

Where \texttt{...A} represents the spread of \texttt{item\_ids}
composing the frequent itemset; and \texttt{B} the support of this
itemset (in term of number of occurency).

Eventhough the output format is not rigorously \texttt{.csv} friendly,
we can still easily parse the output file with our TypeScript
application with no addtionnal dependency or need of code; using a
little hack, defining the string \texttt{\#SUP:} as a \texttt{.csv}
separator. This will result in us parsing an Array of 2-item rows:

\begin{verbatim}
[ ...item_ids, support ]
\end{verbatim}

This is own our homemade SPMF wrapper inherently works.

\emph{EDIT: V2 of SPMF Wrapper uses Regular Expressions, see below}

Last step will trivially be to parse those item\_ids and joining these
results with the \texttt{products.csv} table for enhanced visualisation.

\hypertarget{maximum-support}{%
\paragraph{Maximum support}\label{maximum-support}}

In the extend of running the Apriori Algorithm, we need to define a
proper minimum support value, as defined above. This is a crucial step,
as setting the support to an exagerated value would result no itemsets
to be find; while setting it to a too low value will inherently result
in a very long execution time.

As seen previously, \texttt{Banana} is the most frequent item in out
dataset, being recorded in 18,726 of the 131,209 transactions
i.e.~14.3\% of all the orders. This number also represents the maximum
support of any itemset in our dataset, as being the support of itemset
composed of the \texttt{Banana} singleton.

\hypertarget{first-runs}{%
\paragraph{First runs}\label{first-runs}}

Let us run Apriori a few times, with a different minimum support
threshold, in order to compare the execution time as well as the number
of return candidates. One small drawback of this implementation being
that it returns single-item candidates (which are not of interest at
all), we'll also specify the number on multiple-items candidates found.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{SPMF} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/class/spmf.class.js\PYZsq{}}\PY{p}{;}
        \PY{k+kr}{import} \PY{p}{\PYZob{}} \PY{n+nx}{SPMFResults}\PY{p}{,} \PY{n+nx}{ItemSet}\PY{p}{,} \PY{n+nx}{Rule} \PY{p}{\PYZcb{}} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./src/class/spmf.class\PYZsq{}}\PY{p}{;}
        
        \PY{k+kd}{function} \PY{n+nx}{aprioriRun}\PY{p}{(}\PY{p}{)}\PY{o}{:} \PY{k}{void} \PY{p}{\PYZob{}}
            \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}async}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}} \PY{o}{=} \PY{k+kc}{true}\PY{p}{;}
            \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Mining patterns, this might take a while...\PYZsq{}}\PY{p}{)}\PY{p}{;}
            \PY{c+c1}{// Our custom SPMF wrapper}
            \PY{k}{new} \PY{n+nx}{SPMF}\PY{p}{.}\PY{n+nx}{SPMF}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Apriori\PYZsq{}}\PY{p}{)}
                \PY{c+c1}{// Loading from file}
                \PY{p}{.}\PY{n+nx}{fromFile}\PY{p}{(}\PY{l+s+sb}{`}\PY{l+s+sb}{custom\PYZus{}data/formatted\PYZus{}itemsets.txt}\PY{l+s+sb}{`}\PY{p}{)}
                \PY{c+c1}{// Executes Apriori with 5\PYZpc{} support}
                \PY{p}{.}\PY{n+nx}{exec}\PY{o}{\PYZlt{}}\PY{n+nx}{ItemSet}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{)}
                \PY{c+c1}{// Listening for results}
                \PY{p}{.}\PY{n+nx}{subscribe}\PY{p}{(}\PY{p}{(}\PY{n+nx}{results}: \PY{k+kt}{SPMFResults}\PY{o}{\PYZlt{}}\PY{n+nx}{ItemSet}\PY{o}{\PYZgt{}}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                    \PY{c+c1}{// Wrapper returns both the stats...}
                    \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Stats:\PYZsq{}}\PY{p}{)}\PY{p}{;}
                    \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{n+nx}{results}\PY{p}{.}\PY{n+nx}{stats}\PY{p}{)}\PY{p}{;}
                    \PY{c+c1}{// ... and the frequent itemsets. Showing the first two itemsets:}
                    \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}First two frequent itemsets:\PYZsq{}}\PY{p}{)}\PY{p}{;}
                    \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{n+nx}{results}\PY{p}{.}\PY{n+nx}{output}\PY{p}{.}\PY{n+nx}{slice}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}\PY{p}{;}
        
                    \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}done}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{(}\PY{p}{)}\PY{p}{;}
                \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
        \PY{p}{\PYZcb{}}
        
        \PY{n+nx}{aprioriRun}\PY{p}{(}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Mining patterns, this might take a while{\ldots}
Stats:
\{ candidates: 28, executionTime: 447, memory: 59.781982421875 \}
First two frequent itemsets:
[ \{ support: 15480, items: [ '13176' ] \},
  \{ support: 10894, items: [ '21137' ] \} ]

    \end{Verbatim}

    \begin{longtable}[]{@{}lllll@{}}
\toprule
\begin{minipage}[b]{0.14\columnwidth}\raggedright
~Minimum support\strut
\end{minipage} & \begin{minipage}[b]{0.18\columnwidth}\raggedright
Number of candidates\strut
\end{minipage} & \begin{minipage}[b]{0.20\columnwidth}\raggedright
Frequent itemsets count\strut
\end{minipage} & \begin{minipage}[b]{0.20\columnwidth}\raggedright
Multiple-items itemsets\strut
\end{minipage} & \begin{minipage}[b]{0.13\columnwidth}\raggedright
Execution time\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.14\columnwidth}\raggedright
13\%\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
1 (Banana, as expected)\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
~1\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
0\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
422 ms\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
7\%\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
10\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
~4\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
0\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
423 ms\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
3\%\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
~153\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
17\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
0\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
748 ms\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
1\%\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
~5,467\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
120\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
14\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
8.2 s\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
0.5\%\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
~33,042\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
364\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
108\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
48.9 s\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
0.3\%\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
~210,892\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
1125\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
478\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
4 mn 58 s\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

As expected, the speed of Apriori gets in the way pretty fast when it
comes to parsing a dataset of such size, and with a maximum support so
low. In order to find more relevant itemsets, we may have to transform
the dataset in order reduce the overall total number of candidates.

\hypertarget{our-first-frequent-itemsets}{%
\paragraph{Our first frequent
itemsets}\label{our-first-frequent-itemsets}}

Results of Apriori runs may be find in folder \texttt{/output}, labelled
as such: \texttt{output\_approri\_\#SUPPORT.txt}. Lets have a look to
multiple-itemed frequent itemsets Apriori has gathered, for a minimum
support of 0.3\%. We want to display our itemsets through a
\href{https://www.zingchart.com/docs/chart-types/chord-diagrams/}{Chord
Chart} using \texttt{zingchart}.

With this intent, we need to format the data, \texttt{zing-chart}-way,
as such:

\begin{verbatim}
{
    name: 'Banana',
    values '0, 1'
}, {
    name: 'Avocado',
    values '1, 0'
}   
\end{verbatim}

\ldots{} where 1 is the support of the itemset
\texttt{\textless{}\{\textquotesingle{}Banana\textquotesingle{},\textquotesingle{}Avocado\textquotesingle{}\}\textgreater{}}.

Such a transformation is quite tedious to explain, but I believe it's
easy to understand line-by-line, though the code below (if not, I do
apologize for any headache I may have cause).

Note that a class representing a Chord node has been created, in which
you can easily manage relations of a serie of nodes. Code is available
in the source codes \texttt{./src/class/chord-serie.class.ts}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{SPMF} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/class/spmf.class.js\PYZsq{}}\PY{p}{;}
        \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{CSVParser} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/class/csv\PYZhy{}parser.class.js\PYZsq{}}\PY{p}{;}
        \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{ChordSerie} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/class/chord\PYZhy{}serie.class.js\PYZsq{}}\PY{p}{;}
        \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{join} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/function/join.function.js\PYZsq{}}
        
        \PY{k+kd}{function} \PY{n+nx}{parseAprioriResults}\PY{p}{(}\PY{p}{)}\PY{o}{:} \PY{k}{void} \PY{p}{\PYZob{}}
            \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}async}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}} \PY{o}{=} \PY{k+kc}{true}\PY{p}{;}
            \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Parsing Apriori results, this might take a while...\PYZsq{}}\PY{p}{)}\PY{p}{;}
           
            \PY{c+c1}{// Loading the \PYZsq{}product.csv\PYZsq{} table.}
            \PY{k}{new} \PY{n+nx}{CSVParser}\PY{p}{.}\PY{n+nx}{CSVParser}\PY{o}{\PYZlt{}}\PY{n+nx}{Product}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+s+sb}{`}\PY{l+s+sb}{instacart\PYZus{}basket\PYZus{}data/products.csv}\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{.}\PY{n+nx}{loadAll}\PY{p}{(}\PY{p}{)}
            \PY{p}{.}\PY{n+nx}{then}\PY{p}{(} \PY{p}{(}\PY{n+nx}{products}: \PY{k+kt}{Product}\PY{p}{[}\PY{p}{]}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Finished loading products\PYZsq{}}\PY{p}{)}\PY{p}{;}
                
                   \PY{c+c1}{// Our custom SPMF wrapper}
                \PY{k}{new} \PY{n+nx}{SPMF}\PY{p}{.}\PY{n+nx}{SPMF}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Apriori\PYZsq{}}\PY{p}{)}
                \PY{p}{.}\PY{n+nx}{loadResultsFromFile}\PY{o}{\PYZlt{}}\PY{n+nx}{ItemSet}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}output/output\PYZus{}apriori\PYZus{}03.txt\PYZsq{}}\PY{p}{)}
                \PY{p}{.}\PY{n+nx}{subscribe}\PY{p}{(}\PY{p}{(}\PY{n+nx}{results}: \PY{k+kt}{SPMFResults}\PY{o}{\PYZlt{}}\PY{n+nx}{ItemSet}\PY{o}{\PYZgt{}}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                    \PY{n+nx}{results}\PY{p}{.}\PY{n+nx}{output} \PY{o}{=} \PY{n+nx}{results}\PY{p}{.}\PY{n+nx}{output}
                        \PY{c+c1}{// Only 2\PYZhy{}item itemsets}
                        \PY{p}{.}\PY{n+nx}{filter}\PY{p}{(} \PY{p}{(}\PY{n+nx}{itemset}: \PY{k+kt}{ItemSet}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{itemset}\PY{p}{.}\PY{n+nx}{items}\PY{p}{.}\PY{n+nx}{length} \PY{o}{==} \PY{l+m+mi}{2} \PY{p}{)}
                        \PY{c+c1}{// Sorted, highest support first}
                        \PY{p}{.}\PY{n+nx}{sort}\PY{p}{(} \PY{p}{(}\PY{n+nx}{a}: \PY{k+kt}{ItemSet}\PY{p}{,} \PY{n+nx}{b}: \PY{k+kt}{ItemSet}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{b}\PY{p}{.}\PY{n+nx}{support} \PY{o}{\PYZhy{}} \PY{n+nx}{a}\PY{p}{.}\PY{n+nx}{support}\PY{p}{)}
                        \PY{c+c1}{// Only the 20 most frequent itemsets}
                        \PY{p}{.}\PY{n+nx}{slice}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{20}\PY{p}{)}\PY{p}{;}
                
                    \PY{c+c1}{// Gathering all items composing the itemsets.}
                    \PY{k+kd}{let} \PY{n+nx}{uniqueItems}: \PY{k+kt}{string}\PY{p}{[}\PY{p}{]} \PY{o}{=} \PY{p}{[}\PY{p}{]}\PY{p}{.}\PY{n+nx}{concat}\PY{p}{.}\PY{n+nx}{apply}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{,} \PY{n+nx}{results}\PY{p}{.}\PY{n+nx}{output}\PY{p}{.}\PY{n+nx}{map}\PY{p}{(} \PY{p}{(}\PY{n+nx}{itemset}: \PY{k+kt}{ItemSet}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{itemset}\PY{p}{.}\PY{n+nx}{items} \PY{p}{)} \PY{p}{)}
                        \PY{c+c1}{// Filtering unique items.}
                        \PY{p}{.}\PY{n+nx}{filter}\PY{p}{(} \PY{p}{(}\PY{n+nx}{itemId}: \PY{k+kt}{string}\PY{p}{,} \PY{n+nx}{index}: \PY{k+kt}{number}\PY{p}{,} \PY{n+nx}{that}: \PY{k+kt}{string}\PY{p}{[}\PY{p}{]}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{that}\PY{p}{.}\PY{n+nx}{indexOf}\PY{p}{(}\PY{n+nx}{itemId}\PY{p}{)} \PY{o}{===} \PY{n+nx}{index} \PY{p}{)}\PY{p}{;}
        
                    \PY{c+c1}{// Mapping unique ids to a ChordSerie node.}
                    \PY{k+kd}{let} \PY{n+nx}{series}: \PY{k+kt}{ChordSerie.ChordSerie}\PY{p}{[}\PY{p}{]} \PY{o}{=} \PY{n+nx}{uniqueItems}\PY{p}{.}\PY{n+nx}{map}\PY{p}{(} \PY{p}{(}\PY{n+nx}{uniqueItemId}: \PY{k+kt}{string}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{k}{new} \PY{n+nx}{ChordSerie}\PY{p}{.}\PY{n+nx}{ChordSerie}\PY{p}{(}\PY{n+nx}{uniqueItemId}\PY{p}{)} \PY{p}{)}\PY{p}{;}
        
                    \PY{c+c1}{// Now we need to populate each node, lets start by noticing all nodes of the size of the array, so they can create inner arrays of such size.}
                    \PY{n+nx}{series}\PY{p}{.}\PY{n+nx}{forEach}\PY{p}{(} \PY{p}{(}\PY{n+nx}{serie}: \PY{k+kt}{ChordSerie.ChordSerie}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{serie}\PY{p}{.}\PY{n+nx}{setSeriesNumber}\PY{p}{(} \PY{n+nx}{series}\PY{p}{.}\PY{n+nx}{length} \PY{p}{)} \PY{p}{)}
        
                    \PY{c+c1}{// Then for each itemset, we need to populate each node}
                    \PY{n+nx}{results}\PY{p}{.}\PY{n+nx}{output}\PY{p}{.}\PY{n+nx}{forEach}\PY{p}{(} \PY{p}{(}\PY{n+nx}{itemset}: \PY{k+kt}{ItemSet}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                        \PY{c+c1}{// So for each items composing the itemset...}
                        \PY{n+nx}{itemset}\PY{p}{.}\PY{n+nx}{items}\PY{p}{.}\PY{n+nx}{forEach}\PY{p}{(} \PY{p}{(}\PY{n+nx}{itemId}: \PY{k+kt}{string}\PY{p}{,} \PY{n+nx}{index}: \PY{k+kt}{number}\PY{p}{,} \PY{n+nx}{that}: \PY{k+kt}{string}\PY{p}{[}\PY{p}{]}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                            \PY{c+c1}{// Copying array just to be sure, shouldn\PYZsq{}t be a problem though.}
                            \PY{k+kd}{let} \PY{n+nx}{copy}: \PY{k+kt}{string}\PY{p}{[}\PY{p}{]} \PY{o}{=} \PY{n+nx}{that}\PY{p}{.}\PY{n+nx}{slice}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{;}
                            \PY{c+c1}{// Deleting the item id we\PYZsq{}re currently parsing}
                            \PY{n+nx}{copy}\PY{p}{.}\PY{n+nx}{splice}\PY{p}{(}\PY{n+nx}{index}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{;}
                            \PY{c+c1}{// Creating an array of all the nodes related to this item id}
                            \PY{k+kd}{let} \PY{n+nx}{indexesOfRelatedNodes}: \PY{k+kt}{number}\PY{p}{[}\PY{p}{]} \PY{o}{=} \PY{n+nx}{copy}\PY{p}{.}\PY{n+nx}{map}\PY{p}{(} \PY{p}{(}\PY{n+nx}{id}: \PY{k+kt}{string}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{uniqueItems}\PY{p}{.}\PY{n+nx}{indexOf}\PY{p}{(}\PY{n+nx}{id}\PY{p}{)} \PY{p}{)}
        
                            \PY{c+c1}{// Noticing the node of its relations}
                            \PY{n+nx}{series}\PY{p}{[}\PY{n+nx}{uniqueItems}\PY{p}{.}\PY{n+nx}{indexOf}\PY{p}{(}\PY{n+nx}{itemId}\PY{p}{)}\PY{p}{]}\PY{p}{.}\PY{n+nx}{addRelation}\PY{p}{(}\PY{n+nx}{itemset}\PY{p}{.}\PY{n+nx}{support}\PY{p}{,} \PY{n+nx}{indexesOfRelatedNodes}\PY{p}{)}\PY{p}{;}
                        \PY{p}{\PYZcb{}}\PY{p}{)}
                    \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
                
                    \PY{k+kd}{let} \PY{n+nx}{chartOptions}: \PY{k+kt}{string} \PY{o}{=}\PY{err}{ }\PY{n+nx}{JSON}\PY{p}{.}\PY{n+nx}{stringify}\PY{p}{(}\PY{p}{\PYZob{}}
                        \PY{n+nx}{id}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}aprioriItemSetChart\PYZsq{}}\PY{p}{,}
                        \PY{n+nx}{data}\PY{o}{:} \PY{p}{\PYZob{}}
                            \PY{n+nx}{type}\PY{o}{:}\PY{l+s+s1}{\PYZsq{}chord\PYZsq{}}\PY{p}{,}
                            \PY{n+nx}{title}\PY{o}{:} \PY{p}{\PYZob{}}
                                \PY{n+nx}{text}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}Top 20 most frequent 2\PYZhy{}items itemsets\PYZsq{}}
                            \PY{p}{\PYZcb{}}\PY{p}{,}
                            \PY{n+nx}{legend}\PY{o}{:} \PY{p}{\PYZob{}}
                                \PY{n+nx}{overflow}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}scroll\PYZsq{}}\PY{p}{,}
                                \PY{n+nx}{layout}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}vertical\PYZsq{}}\PY{p}{,}
                                \PY{n+nx}{width}: \PY{k+kt}{200}
                            \PY{p}{\PYZcb{}}\PY{p}{,}
                            \PY{n+nx}{options}\PY{o}{:} \PY{p}{\PYZob{}}
                                \PY{l+s+s1}{\PYZsq{}angle\PYZhy{}padding\PYZsq{}}\PY{o}{:} \PY{l+m+mi}{1}\PY{p}{,}
                                \PY{l+s+s1}{\PYZsq{}band\PYZhy{}width\PYZsq{}}\PY{o}{:} \PY{l+m+mi}{10}\PY{p}{,}
                                \PY{l+s+s1}{\PYZsq{}band\PYZhy{}space\PYZsq{}}\PY{o}{:} \PY{l+m+mi}{5}\PY{p}{,}
                                \PY{l+s+s1}{\PYZsq{}radius\PYZsq{}}\PY{o}{:} \PY{l+m+mi}{190}\PY{p}{,}
                                \PY{n+nx}{style}\PY{o}{:} \PY{p}{\PYZob{}}
                                    \PY{n+nx}{band}\PY{o}{:} \PY{p}{\PYZob{}} \PY{p}{\PYZcb{}}\PY{p}{,}
                                    \PY{c+c1}{//chord: \PYZob{} \PYZsq{}border\PYZhy{}width\PYZsq{}: 0, flat: true \PYZcb{},}
                                    \PY{n+nx}{tick}\PY{o}{:} \PY{p}{\PYZob{}} \PY{n+nx}{visible}: \PY{k+kt}{false} \PY{p}{\PYZcb{}}\PY{p}{,}
                                    \PY{n+nx}{item}\PY{o}{:} \PY{p}{\PYZob{}} \PY{n+nx}{visible}: \PY{k+kt}{false} \PY{p}{\PYZcb{}}\PY{p}{,}
                                    \PY{n+nx}{label}\PY{o}{:} \PY{p}{\PYZob{}} \PY{n+nx}{visible}: \PY{k+kt}{false} \PY{p}{\PYZcb{}}
                                \PY{p}{\PYZcb{}}\PY{p}{,}
                            \PY{p}{\PYZcb{}}\PY{p}{,}
                            \PY{n+nx}{tooltip}\PY{o}{:}\PY{p}{\PYZob{}}\PY{p}{\PYZcb{}}\PY{p}{,}
                            \PY{c+c1}{// Populating with product names}
                            \PY{n+nx}{series}: \PY{k+kt}{series.map}\PY{p}{(} \PY{p}{(}\PY{n+nx}{serie}: \PY{k+kt}{ChordSerie.ChordSerie}\PY{p}{[}\PY{p}{]}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{serie}\PY{p}{.}\PY{n+nx}{getSerie}\PY{p}{(} \PY{p}{(}\PY{n+nx}{id}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{join}\PY{p}{.}\PY{n+nx}{join}\PY{o}{\PYZlt{}}\PY{n+nx}{Product}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{n+nx}{products}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}product\PYZus{}id\PYZsq{}}\PY{p}{,} \PY{n+nx}{id}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}product\PYZus{}name\PYZsq{}}\PY{p}{)} \PY{p}{)} \PY{p}{)}\PY{p}{,}
                        \PY{p}{\PYZcb{}}
                    \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
                    
                    \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{.}\PY{n+nx}{html}\PY{p}{(}\PY{l+s+sb}{`}
        \PY{l+s+sb}{                \PYZlt{}div id=\PYZdq{}aprioriItemSetChart\PYZdq{}\PYZgt{}\PYZlt{}/div\PYZgt{}}
        \PY{l+s+sb}{                \PYZlt{}script\PYZgt{}}
        \PY{l+s+sb}{                  zingchart.render(}\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{chartOptions}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{);}
        \PY{l+s+sb}{                \PYZlt{}/script\PYZgt{}}
        \PY{l+s+sb}{            }\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{;}
        
                    \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}done}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{(}\PY{p}{)}\PY{p}{;}
                \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
            \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
        \PY{p}{\PYZcb{}}
        
        \PY{n+nx}{parseAprioriResults}\PY{p}{(}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Parsing Apriori results, this might take a while{\ldots}
Finished loading products

    \end{Verbatim}

    Chart above has been populated with the 20 most popular 2-item itemsets
mined by Apriori with a minimum support of 0.3\%; the chords of the
chart reprensenting the itemsets, of which you can have the support by
hovering the graph with your mouse.

It gives a visual idea of which items are often bought together
(featuring the itemsets and their support through the chords), as well
as the most popular items within these itemsets.

It is worth noticing that only 13 products share all top 20 most
frequent 2-itemed itemset sets.

Fruits and vegetables appears to be over represented within the frequent
itemsets, which makes sense, as fruits and vegetables are very often the
products we buy altogether when going to the supermarket. Yet within the
aisle, from a marketing point of view, it could be interesting to
organise the products such as the most popular items are apart each
other. One may be tempted to buy \texttt{Apples} on his way to find
\texttt{Strawberries} after weightening his freshly bought
\texttt{Bananas}; most frequent 2-item itemset being
\texttt{\textless{}\{"Banana","Organic\ Strawberries"\}\textgreater{}}.

In addition, 3 itemsets have also be mined, and it can be of interest to
take a glance at them:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{SPMF} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/class/spmf.class.js\PYZsq{}}\PY{p}{;}
         \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{CSVParser} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/class/csv\PYZhy{}parser.class.js\PYZsq{}}\PY{p}{;}
         \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{join} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/function/join.function.js\PYZsq{}}
         
         \PY{k+kd}{function} \PY{n+nx}{threeItemSets}\PY{p}{(}\PY{p}{)}\PY{o}{:} \PY{k}{void} \PY{p}{\PYZob{}}
             \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}async}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}} \PY{o}{=} \PY{k+kc}{true}\PY{p}{;}
             \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Parsing Apriori results, this might take a while...\PYZsq{}}\PY{p}{)}\PY{p}{;}
            
             \PY{c+c1}{// Loading the \PYZsq{}product.csv\PYZsq{} table.}
             \PY{k}{new} \PY{n+nx}{CSVParser}\PY{p}{.}\PY{n+nx}{CSVParser}\PY{o}{\PYZlt{}}\PY{n+nx}{Product}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+s+sb}{`}\PY{l+s+sb}{instacart\PYZus{}basket\PYZus{}data/products.csv}\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{.}\PY{n+nx}{loadAll}\PY{p}{(}\PY{p}{)}
             \PY{p}{.}\PY{n+nx}{then}\PY{p}{(} \PY{p}{(}\PY{n+nx}{products}: \PY{k+kt}{Product}\PY{p}{[}\PY{p}{]}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                 \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Finished loading products\PYZsq{}}\PY{p}{)}\PY{p}{;}
                 
                    \PY{c+c1}{// Our custom SPMF wrapper}
                 \PY{k}{new} \PY{n+nx}{SPMF}\PY{p}{.}\PY{n+nx}{SPMF}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Apriori\PYZsq{}}\PY{p}{)}
                 \PY{p}{.}\PY{n+nx}{loadResultsFromFile}\PY{o}{\PYZlt{}}\PY{n+nx}{ItemSet}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}output/output\PYZus{}apriori\PYZus{}03.txt\PYZsq{}}\PY{p}{)}
                 \PY{p}{.}\PY{n+nx}{subscribe}\PY{p}{(}\PY{p}{(}\PY{n+nx}{results}: \PY{k+kt}{SPMFResults}\PY{o}{\PYZlt{}}\PY{n+nx}{ItemSet}\PY{o}{\PYZgt{}}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                     \PY{k+kd}{let} \PY{n+nx}{rows}: \PY{k+kt}{string} \PY{o}{=} \PY{n+nx}{results}\PY{p}{.}\PY{n+nx}{output}
                         \PY{c+c1}{// Only 2\PYZhy{}item itemsets}
                         \PY{p}{.}\PY{n+nx}{filter}\PY{p}{(} \PY{p}{(}\PY{n+nx}{itemset}: \PY{k+kt}{ItemSet}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{itemset}\PY{p}{.}\PY{n+nx}{items}\PY{p}{.}\PY{n+nx}{length} \PY{o}{\PYZgt{}} \PY{l+m+mi}{2} \PY{p}{)}
                         \PY{c+c1}{// Sorted, highest support first}
                         \PY{p}{.}\PY{n+nx}{sort}\PY{p}{(} \PY{p}{(}\PY{n+nx}{a}: \PY{k+kt}{ItemSet}\PY{p}{,} \PY{n+nx}{b}: \PY{k+kt}{ItemSet}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{b}\PY{p}{.}\PY{n+nx}{support} \PY{o}{\PYZhy{}} \PY{n+nx}{a}\PY{p}{.}\PY{n+nx}{support}\PY{p}{)}
                         \PY{c+c1}{// Creating HTML Rows}
                         \PY{p}{.}\PY{n+nx}{map}\PY{p}{(} \PY{p}{(}\PY{n+nx}{itemset}: \PY{k+kt}{ItemSet}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                             \PY{k+kd}{let} \PY{n+nx}{items}: \PY{k+kt}{string}\PY{p}{[}\PY{p}{]} \PY{o}{=} \PY{n+nx}{itemset}\PY{p}{.}\PY{n+nx}{items}\PY{p}{.}\PY{n+nx}{map}\PY{p}{(} \PY{p}{(}\PY{n+nx}{id}: \PY{k+kt}{string}\PY{p}{[}\PY{p}{]}\PY{p}{)}  \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                                 \PY{k}{return} \PY{l+s+sb}{`}\PY{l+s+sb}{\PYZlt{}td\PYZgt{}}\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{join}\PY{p}{.}\PY{n+nx}{join}\PY{o}{\PYZlt{}}\PY{n+nx}{Product}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{n+nx}{products}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}product\PYZus{}id\PYZsq{}}\PY{p}{,} \PY{n+nx}{id}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}product\PYZus{}name\PYZsq{}}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{\PYZlt{}/td\PYZgt{}}\PY{l+s+sb}{`}
                             \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
                             
                             \PY{k}{return} \PY{l+s+sb}{`}\PY{l+s+sb}{\PYZlt{}tr\PYZgt{}}\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{items}\PY{p}{.}\PY{n+nx}{join}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}\PYZsq{}}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{\PYZlt{}td\PYZgt{}}\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{itemset}\PY{p}{.}\PY{n+nx}{support}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{\PYZlt{}/td\PYZgt{}\PYZlt{}/tr\PYZgt{}}\PY{l+s+sb}{`}\PY{p}{;}
                         \PY{p}{\PYZcb{}}\PY{p}{)}
                         \PY{c+c1}{// Only the 10 most frequent itemsets}
                         \PY{p}{.}\PY{n+nx}{slice}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{;}
                         
                     \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{.}\PY{n+nx}{html}\PY{p}{(}\PY{l+s+sb}{`}
         \PY{l+s+sb}{                \PYZlt{}h3\PYZgt{}Top 10 3\PYZhy{}items frequent itemsets\PYZlt{}/h3\PYZgt{}}
         \PY{l+s+sb}{                \PYZlt{}table style=\PYZdq{}width:100\PYZpc{}\PYZdq{}\PYZgt{}}
         \PY{l+s+sb}{                  \PYZlt{}tr\PYZgt{}}
         \PY{l+s+sb}{                    \PYZlt{}th\PYZgt{}Item 1\PYZlt{}/th\PYZgt{}}
         \PY{l+s+sb}{                    \PYZlt{}th\PYZgt{}Item 2\PYZlt{}/th\PYZgt{} }
         \PY{l+s+sb}{                    \PYZlt{}th\PYZgt{}Item 3\PYZlt{}/th\PYZgt{}}
         \PY{l+s+sb}{                    \PYZlt{}th\PYZgt{}Support\PYZlt{}/th\PYZgt{}}
         \PY{l+s+sb}{                  \PYZlt{}/tr\PYZgt{}}
         \PY{l+s+sb}{                  }\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{rows}\PY{p}{.}\PY{n+nx}{join}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}\PYZsq{}}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}
         \PY{l+s+sb}{                \PYZlt{}/table\PYZgt{}}
         \PY{l+s+sb}{            }\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{;}
                     
                     \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}done}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{(}\PY{p}{)}\PY{p}{;}
                 \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
             \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
         \PY{p}{\PYZcb{}}
         
         \PY{n+nx}{threeItemSets}\PY{p}{(}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Parsing Apriori results, this might take a while{\ldots}
Finished loading products

    \end{Verbatim}

    It's pretty fun to see that the top 5 (6 out of top 10) of most commonly
bought-together products are all itemsets of \textbf{organic} products.
This really represents the new trend and consumer habit of buying only
organic products: One having in mind to buy organic products will only
buy organic products. This behaviour result in creating interesting
frequent datasets!

These frequent itemsets clealy points towards associations rules stating
\texttt{If\ one\ buys\ 2\ organic\ products,\ he\ will\ buy\ 1\ other\ organic\ products}
with a very high confidence. Let's keep this idea in mind for later.

\hypertarget{lcm-algorithm}{%
\subsubsection{LCM Algorithm}\label{lcm-algorithm}}

LCM is an algorithm know to be the fastest for mining frequent
\textbf{closed} itemsets; knowing that an itemset X is closed in a
dataset S if no proper super-itemset Y that has the same support count
as X in S exists. Main reason of mining closed frequent datasets over
all datasets is that such a set is usually much smaller than the set of
frequent itemsets, eventhough no information is lost, as the entire set
can be regenerated from the closed set{[}2{]}.

We will be using SPMF library's JAVA implementation of LCM, in order to
mine frequent closed itemsets from our dataset; An advantage beingi that
this implementation inputs the same file format as the Apriori Algorithm
of the same library, thus, there is no need to format our dataset in a
different manner.

\hypertarget{running-the-algorithm}{%
\paragraph{Running the algorithm}\label{running-the-algorithm}}

It would be interesting to compare the performances and results of the
LCM and Apriori algorithms; thus, let's run LCM over the same dataset
again, and with the same support. You can also try it by yourself by
executing the code below:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{SPMF} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/class/spmf.class.js\PYZsq{}}\PY{p}{;}
         
         \PY{k+kd}{function} \PY{n+nx}{lcmRun}\PY{p}{(}\PY{p}{)}\PY{o}{:} \PY{k}{void} \PY{p}{\PYZob{}}
             \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}async}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}} \PY{o}{=} \PY{k+kc}{true}\PY{p}{;}
             \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Mining patterns, this might take a while...\PYZsq{}}\PY{p}{)}\PY{p}{;}
             \PY{c+c1}{// Our custom SPMF wrapper}
             \PY{k}{new} \PY{n+nx}{SPMF}\PY{p}{.}\PY{n+nx}{SPMF}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}LCM\PYZsq{}}\PY{p}{)}
                 \PY{c+c1}{// Loading from file}
                 \PY{p}{.}\PY{n+nx}{fromFile}\PY{p}{(}\PY{l+s+sb}{`}\PY{l+s+sb}{custom\PYZus{}data/formatted\PYZus{}itemsets.txt}\PY{l+s+sb}{`}\PY{p}{)}
                 \PY{c+c1}{// Executes LCM with 5\PYZpc{} support}
                 \PY{p}{.}\PY{n+nx}{exec}\PY{o}{\PYZlt{}}\PY{n+nx}{ItemSet}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{)}
                 \PY{c+c1}{// Listening for results}
                 \PY{p}{.}\PY{n+nx}{subscribe}\PY{p}{(}\PY{p}{(}\PY{n+nx}{results}: \PY{k+kt}{SPMFResults}\PY{o}{\PYZlt{}}\PY{n+nx}{ItemSet}\PY{o}{\PYZgt{}}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                     \PY{c+c1}{// Wrapper returns both the stats...}
                     \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Stats:\PYZsq{}}\PY{p}{)}\PY{p}{;}
                     \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{n+nx}{results}\PY{p}{.}\PY{n+nx}{stats}\PY{p}{)}\PY{p}{;}
                     \PY{c+c1}{// ... and the frequent itemsets. Showing the first two itemsets:}
                     \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}First two frequent itemsets:\PYZsq{}}\PY{p}{)}\PY{p}{;}
                     \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{n+nx}{results}\PY{p}{.}\PY{n+nx}{output}\PY{p}{.}\PY{n+nx}{slice}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}\PY{p}{;}
         
                     \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}done}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{(}\PY{p}{)}\PY{p}{;}
                 \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
         \PY{p}{\PYZcb{}}
         
         \PY{n+nx}{lcmRun}\PY{p}{(}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Mining patterns, this might take a while{\ldots}
Stats:
\{ candidates: undefined, executionTime: 353, memory: undefined \}
First two frequent itemsets:
[ \{ support: 15480, items: [ '13176' ] \},
  \{ support: 10894, items: [ '21137' ] \} ]

    \end{Verbatim}

    \begin{longtable}[]{@{}lllll@{}}
\toprule
\begin{minipage}[b]{0.14\columnwidth}\raggedright
~Minimum support\strut
\end{minipage} & \begin{minipage}[b]{0.18\columnwidth}\raggedright
Frequent closed itemsets count\strut
\end{minipage} & \begin{minipage}[b]{0.20\columnwidth}\raggedright
Multiple-items itemsets\strut
\end{minipage} & \begin{minipage}[b]{0.20\columnwidth}\raggedright
Execution time\strut
\end{minipage} & \begin{minipage}[b]{0.13\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.14\columnwidth}\raggedright
13\%\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
~1\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
0\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
204 ms\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
7\%\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
~4\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
0\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
275 ms\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
3\%\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
17\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
0\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
328 ms\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
1\%\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
120\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
16\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
1.2 s\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
0.5\%\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
~364\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
108\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
2.3 s\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
0.3\%\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
~1125\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
339\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
4.9 s\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
0.1\%\strut
\end{minipage} & \begin{minipage}[t]{0.18\columnwidth}\raggedright
~4444\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedright
24.4 s\strut
\end{minipage} & \begin{minipage}[t]{0.13\columnwidth}\raggedright
\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{lets-reduce-the-minimum-support-even-more}{%
\paragraph{Let's reduce the minimum support even more
!}\label{lets-reduce-the-minimum-support-even-more}}

Enhanced perfomances of LCM over Apriori allows us to reduce the minimum
even more while mining patterns on our dataset with decent executing
times (See table above, with an execution for a minimum support of
.1\%). This allowed us to find some quite revealant 4-items itemsets,
with still a decent support value:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{SPMF} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/class/spmf.class.js\PYZsq{}}\PY{p}{;}
         \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{CSVParser} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/class/csv\PYZhy{}parser.class.js\PYZsq{}}\PY{p}{;}
         \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{join} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/function/join.function.js\PYZsq{}}
         
         \PY{k+kd}{function} \PY{n+nx}{lcmItemsets}\PY{p}{(}\PY{p}{)}\PY{o}{:} \PY{k}{void} \PY{p}{\PYZob{}}
             \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}async}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}} \PY{o}{=} \PY{k+kc}{true}\PY{p}{;}
             \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Mining patterns, this might take a while...\PYZsq{}}\PY{p}{)}\PY{p}{;}
             
             \PY{k}{new} \PY{n+nx}{CSVParser}\PY{p}{.}\PY{n+nx}{CSVParser}\PY{o}{\PYZlt{}}\PY{n+nx}{Product}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+s+sb}{`}\PY{l+s+sb}{instacart\PYZus{}basket\PYZus{}data/products.csv}\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{.}\PY{n+nx}{loadAll}\PY{p}{(}\PY{p}{)}
             \PY{p}{.}\PY{n+nx}{then}\PY{p}{(} \PY{p}{(}\PY{n+nx}{products}: \PY{k+kt}{Product}\PY{p}{[}\PY{p}{]}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                 \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Finished loading products\PYZsq{}}\PY{p}{)}\PY{p}{;}
             
                 \PY{c+c1}{// Our custom SPMF wrapper}
                 \PY{k}{new} \PY{n+nx}{SPMF}\PY{p}{.}\PY{n+nx}{SPMF}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}LCM\PYZsq{}}\PY{p}{)}
                     \PY{c+c1}{// Loading from file}
                     \PY{c+c1}{//.fromFile(`custom\PYZus{}data/formatted\PYZus{}itemsets.txt`)}
                     \PY{c+c1}{// Executes LCM with .1\PYZpc{} support}
                     \PY{c+c1}{//.exec\PYZlt{}ItemSet\PYZgt{}(.1)       }
                     \PY{p}{.}\PY{n+nx}{loadResultsFromFile}\PY{o}{\PYZlt{}}\PY{n+nx}{ItemSet}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}output/output\PYZus{}lcm\PYZus{}01.txt\PYZsq{}}\PY{p}{)}
                     \PY{c+c1}{// Listening for results}
                     \PY{p}{.}\PY{n+nx}{subscribe}\PY{p}{(}\PY{p}{(}\PY{n+nx}{results}: \PY{k+kt}{SPMFResults}\PY{o}{\PYZlt{}}\PY{n+nx}{ItemSet}\PY{o}{\PYZgt{}}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                         \PY{k+kd}{let} \PY{n+nx}{rows}: \PY{k+kt}{string} \PY{o}{=} \PY{n+nx}{results}\PY{p}{.}\PY{n+nx}{output}
                             \PY{c+c1}{// Only 2\PYZhy{}item itemsets}
                             \PY{p}{.}\PY{n+nx}{filter}\PY{p}{(} \PY{p}{(}\PY{n+nx}{itemset}: \PY{k+kt}{ItemSet}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{itemset}\PY{p}{.}\PY{n+nx}{items}\PY{p}{.}\PY{n+nx}{length} \PY{o}{\PYZgt{}} \PY{l+m+mi}{3} \PY{p}{)}
                             \PY{c+c1}{// Sorted, highest support first}
                             \PY{p}{.}\PY{n+nx}{sort}\PY{p}{(} \PY{p}{(}\PY{n+nx}{a}: \PY{k+kt}{ItemSet}\PY{p}{,} \PY{n+nx}{b}: \PY{k+kt}{ItemSet}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{b}\PY{p}{.}\PY{n+nx}{support} \PY{o}{\PYZhy{}} \PY{n+nx}{a}\PY{p}{.}\PY{n+nx}{support}\PY{p}{)}
                             \PY{c+c1}{// Creating HTML Rows}
                             \PY{p}{.}\PY{n+nx}{map}\PY{p}{(} \PY{p}{(}\PY{n+nx}{itemset}: \PY{k+kt}{ItemSet}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                                 \PY{k+kd}{let} \PY{n+nx}{items}: \PY{k+kt}{string}\PY{p}{[}\PY{p}{]} \PY{o}{=} \PY{n+nx}{itemset}\PY{p}{.}\PY{n+nx}{items}\PY{p}{.}\PY{n+nx}{map}\PY{p}{(} \PY{p}{(}\PY{n+nx}{id}: \PY{k+kt}{string}\PY{p}{[}\PY{p}{]}\PY{p}{)}  \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                                     \PY{k}{return} \PY{l+s+sb}{`}\PY{l+s+sb}{\PYZlt{}td\PYZgt{}}\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{join}\PY{p}{.}\PY{n+nx}{join}\PY{o}{\PYZlt{}}\PY{n+nx}{Product}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{n+nx}{products}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}product\PYZus{}id\PYZsq{}}\PY{p}{,} \PY{n+nx}{id}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}product\PYZus{}name\PYZsq{}}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{\PYZlt{}/td\PYZgt{}}\PY{l+s+sb}{`}
                                 \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
         
                                 \PY{k}{return} \PY{l+s+sb}{`}\PY{l+s+sb}{\PYZlt{}tr\PYZgt{}}\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{items}\PY{p}{.}\PY{n+nx}{join}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}\PYZsq{}}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{\PYZlt{}td\PYZgt{}}\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{itemset}\PY{p}{.}\PY{n+nx}{support}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{\PYZlt{}/td\PYZgt{}\PYZlt{}/tr\PYZgt{}}\PY{l+s+sb}{`}\PY{p}{;}
                             \PY{p}{\PYZcb{}}\PY{p}{)}
                             \PY{c+c1}{// Only the 10 most frequent itemsets}
                             \PY{p}{.}\PY{n+nx}{slice}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{;}
         
                         \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{.}\PY{n+nx}{html}\PY{p}{(}\PY{l+s+sb}{`}
         \PY{l+s+sb}{                    \PYZlt{}h3\PYZgt{}4\PYZhy{}items frequent itemsets\PYZlt{}/h3\PYZgt{}}
         \PY{l+s+sb}{                    \PYZlt{}table style=\PYZdq{}width:100\PYZpc{}\PYZdq{}\PYZgt{}}
         \PY{l+s+sb}{                      \PYZlt{}tr\PYZgt{}}
         \PY{l+s+sb}{                        \PYZlt{}th\PYZgt{}Item 1\PYZlt{}/th\PYZgt{}}
         \PY{l+s+sb}{                        \PYZlt{}th\PYZgt{}Item 2\PYZlt{}/th\PYZgt{} }
         \PY{l+s+sb}{                        \PYZlt{}th\PYZgt{}Item 3\PYZlt{}/th\PYZgt{}}
         \PY{l+s+sb}{                        \PYZlt{}th\PYZgt{}Item 4\PYZlt{}/th\PYZgt{}}
         \PY{l+s+sb}{                        \PYZlt{}th\PYZgt{}Support\PYZlt{}/th\PYZgt{}}
         \PY{l+s+sb}{                      \PYZlt{}/tr\PYZgt{}}
         \PY{l+s+sb}{                      }\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{rows}\PY{p}{.}\PY{n+nx}{join}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}\PYZsq{}}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}
         \PY{l+s+sb}{                    \PYZlt{}/table\PYZgt{}}
         \PY{l+s+sb}{                }\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{;}
         
                         \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}done}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{(}\PY{p}{)}\PY{p}{;}
                     \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
             \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
         \PY{p}{\PYZcb{}}
         
         \PY{n+nx}{lcmItemsets}\PY{p}{(}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Mining patterns, this might take a while{\ldots}
Finished loading products

    \end{Verbatim}

    These results points in the same way than our previous observations:
organic products tends to be bought alltogether.

\hypertarget{quick-comparison-of-lcm-and-apriori}{%
\subsubsection{Quick comparison of LCM and
Apriori}\label{quick-comparison-of-lcm-and-apriori}}

Let's have a quick look over the behaviours and execution of both tested
algorithms:

\begin{longtable}[]{@{}lll@{}}
\toprule
~Minimum support & Apriori execution time & LCM execution
time\tabularnewline
\midrule
\endhead
13\% & 422 ms & 204 ms\tabularnewline
7\% & 423 ms & 275 ms\tabularnewline
3\% & 748 ms & 328 ms\tabularnewline
1\% & 8.2 s & 1.2 s\tabularnewline
0.5\% & 48.9 s & 1.3 s\tabularnewline
0.3\% & 4 mn 58s & 4.9 s\tabularnewline
\bottomrule
\end{longtable}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{k+kd}{function} \PY{n+nx}{executionTimeChart}\PY{p}{(}\PY{p}{)}\PY{o}{:} \PY{k}{void} \PY{p}{\PYZob{}}
         
             \PY{k+kd}{let} \PY{n+nx}{chartOptions}: \PY{k+kt}{string} \PY{o}{=}\PY{err}{ }\PY{n+nx}{JSON}\PY{p}{.}\PY{n+nx}{stringify}\PY{p}{(}\PY{p}{\PYZob{}}
                 \PY{n+nx}{id}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}executionTimeChart\PYZsq{}}\PY{p}{,}
                 \PY{n+nx}{data}\PY{o}{:} \PY{p}{\PYZob{}}
                     \PY{n+nx}{type}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}line\PYZsq{}}\PY{p}{,}
                     \PY{n+nx}{scaleY}\PY{o}{:} \PY{p}{\PYZob{}}
                         \PY{n+nx}{progression}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}log\PYZsq{}}\PY{p}{,}
                         \PY{n+nx}{logBase}: \PY{k+kt}{10}\PY{p}{,}
                         \PY{n+nx}{label}\PY{o}{:} \PY{p}{\PYZob{}}
                           \PY{n+nx}{text}\PY{o}{:} \PY{l+s+s2}{\PYZdq{}Execution time (s)\PYZdq{}}
                         \PY{p}{\PYZcb{}}\PY{p}{,}
                         \PY{n+nx}{item}\PY{o}{:} \PY{p}{\PYZob{}}
                           \PY{n+nx}{fontSize}: \PY{k+kt}{10}
                         \PY{p}{\PYZcb{}}\PY{p}{,}
                     \PY{p}{\PYZcb{}}\PY{p}{,}
                     \PY{n+nx}{scaleX}\PY{o}{:} \PY{p}{\PYZob{}}
                         \PY{n+nx}{values}\PY{o}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}13\PYZpc{}\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}7\PYZpc{}\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}3\PYZpc{}\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}1\PYZpc{}\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}0.5\PYZpc{}\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}0.3\PYZpc{}\PYZsq{}}\PY{p}{]}\PY{p}{,}
                         \PY{n+nx}{label}\PY{o}{:} \PY{p}{\PYZob{}}
                           \PY{n+nx}{text}\PY{o}{:} \PY{l+s+s2}{\PYZdq{}Minimum support (\PYZpc{})\PYZdq{}}
                         \PY{p}{\PYZcb{}}\PY{p}{,}
                         \PY{n+nx}{item}\PY{o}{:} \PY{p}{\PYZob{}}
                           \PY{n+nx}{fontSize}: \PY{k+kt}{10}
                         \PY{p}{\PYZcb{}}\PY{p}{,}
                     \PY{p}{\PYZcb{}}\PY{p}{,}
                     \PY{n+nx}{title}\PY{o}{:} \PY{p}{\PYZob{}}
                         \PY{n+nx}{text}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}Execution time (in seconds) of either Apriori or LCM\PYZsq{}}
                     \PY{p}{\PYZcb{}}\PY{p}{,}
                     \PY{n+nx}{legend}\PY{o}{:} \PY{p}{\PYZob{}}
             
                     \PY{p}{\PYZcb{}}\PY{p}{,}
                     \PY{n+nx}{series}\PY{o}{:} \PY{p}{[}
                         \PY{p}{\PYZob{}} \PY{n+nx}{values}\PY{o}{:} \PY{p}{[}\PY{p}{.}\PY{l+m+mi}{422}\PY{p}{,}\PY{p}{.}\PY{l+m+mi}{423}\PY{p}{,}\PY{p}{.}\PY{l+m+mi}{748}\PY{p}{,}\PY{l+m+mf}{8.2}\PY{p}{,}\PY{l+m+mi}{48}\PY{p}{,}\PY{l+m+mi}{298}\PY{p}{]}\PY{p}{,} \PY{n+nx}{text}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}Apriori\PYZsq{}} \PY{p}{\PYZcb{}}\PY{p}{,}
                         \PY{p}{\PYZob{}} \PY{n+nx}{values}\PY{o}{:} \PY{p}{[}\PY{p}{.}\PY{l+m+mi}{204}\PY{p}{,}\PY{p}{.}\PY{l+m+mi}{275}\PY{p}{,}\PY{p}{.}\PY{l+m+mi}{328}\PY{p}{,}\PY{l+m+mf}{1.2}\PY{p}{,}\PY{l+m+mf}{1.3}\PY{p}{,}\PY{l+m+mf}{4.9}\PY{p}{]}\PY{p}{,} \PY{n+nx}{text}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}LCM\PYZsq{}} \PY{p}{\PYZcb{}}
                     \PY{p}{]}
                 \PY{p}{\PYZcb{}}
             \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
         
             \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{.}\PY{n+nx}{html}\PY{p}{(}\PY{l+s+sb}{`}
         \PY{l+s+sb}{        \PYZlt{}div id=\PYZdq{}executionTimeChart\PYZdq{}\PYZgt{}\PYZlt{}/div\PYZgt{}}
         \PY{l+s+sb}{        \PYZlt{}script\PYZgt{}}
         \PY{l+s+sb}{          zingchart.render(}\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{chartOptions}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{);}
         \PY{l+s+sb}{        \PYZlt{}/script\PYZgt{}}
         \PY{l+s+sb}{    }\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{;}
         
         \PY{p}{\PYZcb{}}\PY{p}{;}
         
         \PY{n+nx}{executionTimeChart}\PY{p}{(}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    In terms of performance, LCM crushed Apriori when it comes to lower
minimum support. This is anything but a surprise, as Apriori is nowadays
outdated, as faster and more memory efficient algorithms for mining
\texttt{all\ datasets} have been proposed since, like \texttt{FPGrowth}
which we will use later. In the meantime, LCM is known to be one of the
most efficient algorithm for mining closed frequent itemsets.

\begin{longtable}[]{@{}lll@{}}
\toprule
~Minimum support & Apriori itemsets count & LCM itemsets
count\tabularnewline
\midrule
\endhead
13\% & 1 & 1\tabularnewline
7\% & 4 & 4\tabularnewline
3\% & 17 & 17\tabularnewline
1\% & 120 & 120\tabularnewline
0.5\% & 364 & 364\tabularnewline
0.3\% & 1125 & 844\tabularnewline
\bottomrule
\end{longtable}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{k+kd}{function} \PY{n+nx}{itemSetChart}\PY{p}{(}\PY{p}{)}\PY{o}{:} \PY{k}{void} \PY{p}{\PYZob{}}
         
             \PY{k+kd}{let} \PY{n+nx}{chartOptions}: \PY{k+kt}{string} \PY{o}{=}\PY{err}{ }\PY{n+nx}{JSON}\PY{p}{.}\PY{n+nx}{stringify}\PY{p}{(}\PY{p}{\PYZob{}}
                 \PY{n+nx}{id}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}itemSetChart\PYZsq{}}\PY{p}{,}
                 \PY{n+nx}{data}\PY{o}{:} \PY{p}{\PYZob{}}
                     \PY{n+nx}{type}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}line\PYZsq{}}\PY{p}{,}
                     \PY{n+nx}{scaleY}\PY{o}{:} \PY{p}{\PYZob{}}
                         \PY{n+nx}{label}\PY{o}{:} \PY{p}{\PYZob{}}
                           \PY{n+nx}{text}\PY{o}{:} \PY{l+s+s2}{\PYZdq{}Itemset returned\PYZdq{}}
                         \PY{p}{\PYZcb{}}\PY{p}{,}
                         \PY{n+nx}{item}\PY{o}{:} \PY{p}{\PYZob{}}
                           \PY{n+nx}{fontSize}: \PY{k+kt}{10}
                         \PY{p}{\PYZcb{}}\PY{p}{,}
                     \PY{p}{\PYZcb{}}\PY{p}{,}
                     \PY{n+nx}{scaleX}\PY{o}{:} \PY{p}{\PYZob{}}
                         \PY{n+nx}{values}\PY{o}{:} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}13\PYZpc{}\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}7\PYZpc{}\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}3\PYZpc{}\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}1\PYZpc{}\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}0.5\PYZpc{}\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}0.3\PYZpc{}\PYZsq{}}\PY{p}{]}\PY{p}{,}
                         \PY{n+nx}{label}\PY{o}{:} \PY{p}{\PYZob{}}
                           \PY{n+nx}{text}\PY{o}{:} \PY{l+s+s2}{\PYZdq{}Minimum support (\PYZpc{})\PYZdq{}}
                         \PY{p}{\PYZcb{}}\PY{p}{,}
                         \PY{n+nx}{item}\PY{o}{:} \PY{p}{\PYZob{}}
                           \PY{n+nx}{fontSize}: \PY{k+kt}{10}
                         \PY{p}{\PYZcb{}}
                     \PY{p}{\PYZcb{}}\PY{p}{,}
                     \PY{n+nx}{title}\PY{o}{:} \PY{p}{\PYZob{}}
                         \PY{n+nx}{text}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}Itemset returned by either Apriori or LCM depending on support\PYZsq{}}
                     \PY{p}{\PYZcb{}}\PY{p}{,}
                     \PY{n+nx}{legend}\PY{o}{:} \PY{p}{\PYZob{}}
             
                     \PY{p}{\PYZcb{}}\PY{p}{,}
                     \PY{n+nx}{series}\PY{o}{:} \PY{p}{[}
                         \PY{p}{\PYZob{}} \PY{n+nx}{values}\PY{o}{:} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{17}\PY{p}{,}\PY{l+m+mi}{120}\PY{p}{,}\PY{l+m+mi}{364}\PY{p}{,}\PY{l+m+mi}{1125}\PY{p}{]}\PY{p}{,} \PY{n+nx}{text}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}Apriori\PYZsq{}} \PY{p}{\PYZcb{}}\PY{p}{,}
                         \PY{p}{\PYZob{}} \PY{n+nx}{values}\PY{o}{:} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{17}\PY{p}{,}\PY{l+m+mi}{120}\PY{p}{,}\PY{l+m+mi}{364}\PY{p}{,}\PY{l+m+mi}{844}\PY{p}{]}\PY{p}{,} \PY{n+nx}{text}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}LCM\PYZsq{}} \PY{p}{\PYZcb{}}
                     \PY{p}{]}
                 \PY{p}{\PYZcb{}}
             \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
         
             \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{.}\PY{n+nx}{html}\PY{p}{(}\PY{l+s+sb}{`}
         \PY{l+s+sb}{        \PYZlt{}div id=\PYZdq{}itemSetChart\PYZdq{}\PYZgt{}\PYZlt{}/div\PYZgt{}}
         \PY{l+s+sb}{        \PYZlt{}script\PYZgt{}}
         \PY{l+s+sb}{          zingchart.render(}\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{chartOptions}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{);}
         \PY{l+s+sb}{        \PYZlt{}/script\PYZgt{}}
         \PY{l+s+sb}{    }\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{;}
         
         \PY{p}{\PYZcb{}}\PY{p}{;}
         
         \PY{n+nx}{itemSetChart}\PY{p}{(}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    In terms of returned itemsets, LCM globally returns let itemsets than
Apriori. This was to be expected given that those Algorithms don't
output the same set of itemsets; Apriori returning all itemsets while
LCM only returns \textbf{closed itemsets}. However it may be of interest
to notice that both algorithms return the \textbf{same} result upon a
certain minimum support given the fact that itemsets returned are closed
no matter what algorithm is used.

    \hypertarget{frequent-item-sets-association-rules}{%
\subsection{Frequent item sets association
rules}\label{frequent-item-sets-association-rules}}

Once patterns have been mined, we can also determine association rules,
as each item may have several relations with others. These relations
thus indirect relationships between the items composing the
transactions; expressed with a certain \textbf{confidence}, as an
example:

\texttt{Diapers\ implies\ beer\ with\ 65\%\ confidence}

\hypertarget{fpgrowth-association-mining}{%
\subsubsection{FPGrowth association
mining}\label{fpgrowth-association-mining}}

Association rules mining generally consist in two steps: the first step
being to discover frequent itemsets (With Apriori, LCM or any other
algorithm as we did previously); and the second, to generate rules by
using these frequent itemsets.

We'll be using in that order yet another all-in-one Algorithm from the
SPMF Library, the \texttt{FPGrowth\_association\_rules} algorithm, which
basically mine item sets using a faster, more memory efficient algorithm
than Apriori: \texttt{FPGrowth}; before generating the association
rules.

Algorithm takes 2 input values: - The minimum support of mined itemsets,
as before; - The minimum confidence of resulting association rules;

\hypertarget{parsing-the-results}{%
\paragraph{Parsing the results}\label{parsing-the-results}}

Parsing the results may defer a bit, as the output file now indicates
rules instead of plain itemsets, the support of the association, as well
as the confidence of the rule.

Example of output:

\begin{verbatim}
1 ==> 2 4 5 #SUP: 3 #CONF: 0.75
5 6 ==> 1 2 4 #SUP: 3 #CONF: 0.6
4 7 ==> 1 #SUP: 3 #CONF: 0.75
\end{verbatim}

Such a file would result in being parsed the following way with our
current code:

\begin{verbatim}
['1 ==> 2 4 5', '3 #CONF: 0.75']
\end{verbatim}

Nothing to worry about though, as a really hacky to do it would be to
\texttt{split()} both resulting strings using separators
\texttt{==\textgreater{}} and \texttt{\#CONF}. I'd really wish I would
have use Regular expressions at this point though\ldots{}

\hypertarget{late-update-regular-expressions}{%
\paragraph{Late update: Regular
expressions}\label{late-update-regular-expressions}}

That was I ended up doing eventually, keeping in mind that we will need
to parse outpit files from even more algorithms (sequential pattern
mining, etc\ldots{}). I'm thus using the following Regular expressions
to match results as they are gatheresd from output files; and using even
more regular expressions within the matches of expressions to parse for
numeric values.

\begin{verbatim}
Matching itemsets:
/^(\d* )+#SUP: (\d*( )*)+\t*\n*\r*$/g

Matching association rules:
/^(\d* )+==> (\d* )+#SUP: (\d* )+#CONF: (\d*)+\.*\d*\t*\n*\r*$/g
\end{verbatim}

\hypertarget{running-the-algorithm}{%
\paragraph{Running the algorithm}\label{running-the-algorithm}}

You can try the algorithm by yourself, by editing and executing the code
below:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{SPMF} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/class/spmf.class.js\PYZsq{}}\PY{p}{;}
         
         \PY{k+kd}{function} \PY{n+nx}{associationRulesMining}\PY{p}{(}\PY{p}{)}\PY{o}{:} \PY{k}{void} \PY{p}{\PYZob{}}
             \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}async}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}} \PY{o}{=} \PY{k+kc}{true}\PY{p}{;}
             \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Mining association rules, this might take a while...\PYZsq{}}\PY{p}{)}\PY{p}{;}
             \PY{c+c1}{// Our custom SPMF wrapper}
             \PY{k}{new} \PY{n+nx}{SPMF}\PY{p}{.}\PY{n+nx}{SPMF}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}FPGrowth\PYZus{}association\PYZus{}rules\PYZsq{}}\PY{p}{)}
                 \PY{c+c1}{// Loading from file}
                 \PY{p}{.}\PY{n+nx}{fromFile}\PY{p}{(}\PY{l+s+sb}{`}\PY{l+s+sb}{custom\PYZus{}data/formatted\PYZus{}itemsets.txt}\PY{l+s+sb}{`}\PY{p}{)}
                 \PY{p}{.}\PY{n+nx}{exec}\PY{o}{\PYZlt{}}\PY{n+nx}{Rule}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+m+mf}{0.1}\PY{p}{,}\PY{l+m+mi}{25}\PY{p}{)}
                 \PY{c+c1}{// Listening for results}
                 \PY{p}{.}\PY{n+nx}{subscribe}\PY{p}{(}\PY{p}{(}\PY{n+nx}{results}: \PY{k+kt}{SPMFResults}\PY{o}{\PYZlt{}}\PY{n+nx}{Rule}\PY{o}{\PYZgt{}}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                     \PY{c+c1}{// Wrapper returns both the stats...}
                     \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Stats:\PYZsq{}}\PY{p}{)}\PY{p}{;}
                     \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{n+nx}{results}\PY{p}{.}\PY{n+nx}{stats}\PY{p}{)}\PY{p}{;}
                     \PY{c+c1}{// ... and the frequent rules. Showing the first two rules:}
                     \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}First two rules mined:\PYZsq{}}\PY{p}{)}\PY{p}{;}     
                     \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{n+nx}{results}\PY{p}{.}\PY{n+nx}{output}\PY{p}{.}\PY{n+nx}{slice}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}\PY{p}{;}
         
                     \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}done}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{(}\PY{p}{)}\PY{p}{;}
                 \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
         \PY{p}{\PYZcb{}}
         
         \PY{n+nx}{associationRulesMining}\PY{p}{(}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Mining association rules, this might take a while{\ldots}
Stats:
\{ candidates: undefined, executionTime: 26, memory: undefined \}
First two rules mined:
[ \{ support: 198,
    confidence: 0.3168,
    items: [ '45' ],
    results: [ '24852' ] \},
  \{ support: 136,
    confidence: 0.3919308357348703,
    items: [ '46149' ],
    results: [ '196' ] \} ]

    \end{Verbatim}

    \hypertarget{association-rules-aisles-relations}{%
\paragraph{Association rules \& Aisles
relations}\label{association-rules-aisles-relations}}

Itemset association rules are great candidates to Chord Diagram
representation. We'll use these mined associations to determine how
aisles interact with each other. The idea we have in mind is simple: We
will map every item and result (which are \texttt{product\_ids}) of each
rule to their \texttt{aisle\_id}, in order to express associations rules
as such:

\texttt{If\ customer\ buys\ a\ product\ from\ aisle\ A\ (and\ B)\ then\ he\ will\ buy\ a\ product\ from\ aisle\ C\ (and\ D)}

From a marketer point of view, we want aisle A (and B) as far as
possible from aisle C (and D)\ldots{} Thus when parsing our newly parsed
rules, keeping our example in mind: Each time we encounter id of
\texttt{Aisle\ A}, we will increment the value linked to the band
(a.k.a. edge) between it and \texttt{Aisle\ C}.

The resulting graph will show the weigted relations between each aisle.

Note that we will not take \texttt{confidence} into account. Given the
fact that minimal confidence as been set to 25\%, we believe confidence
value should not be a discriminative factor for mapping aisles
(probability of each is high).

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}37}]:} \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{SPMF} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/class/spmf.class.js\PYZsq{}}\PY{p}{;}
         \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{CSVParser} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/class/csv\PYZhy{}parser.class.js\PYZsq{}}\PY{p}{;}
         \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{ChordSerie} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/class/chord\PYZhy{}serie.class.js\PYZsq{}}\PY{p}{;}
         \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{join} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/function/join.function.js\PYZsq{}}
         
         \PY{k+kd}{function} \PY{n+nx}{parseAssociationRules}\PY{p}{(} \PY{n+nx}{ignoreIds}: \PY{k+kt}{string}\PY{p}{[}\PY{p}{]} \PY{o}{=} \PY{p}{[}\PY{p}{]} \PY{p}{)}\PY{o}{:} \PY{k}{void} \PY{p}{\PYZob{}}
             \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}async}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}} \PY{o}{=} \PY{k+kc}{true}\PY{p}{;}
             \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Parsing association rules, this might take a while...\PYZsq{}}\PY{p}{)}\PY{p}{;}
            
             \PY{k+kd}{let} \PY{n+nx}{products}: \PY{k+kt}{Product}\PY{p}{[}\PY{p}{]} \PY{o}{=} \PY{p}{[}\PY{p}{]}\PY{p}{;}
             \PY{k+kd}{let} \PY{n+nx}{aisles}: \PY{k+kt}{Aisle}\PY{p}{[}\PY{p}{]} \PY{o}{=} \PY{p}{[}\PY{p}{]}
             
             \PY{c+c1}{// Loading the \PYZsq{}product.csv\PYZsq{} table.}
             \PY{k}{new} \PY{n+nx}{CSVParser}\PY{p}{.}\PY{n+nx}{CSVParser}\PY{o}{\PYZlt{}}\PY{n+nx}{Product}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+s+sb}{`}\PY{l+s+sb}{instacart\PYZus{}basket\PYZus{}data/products.csv}\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{.}\PY{n+nx}{loadAll}\PY{p}{(}\PY{p}{)}
             \PY{p}{.}\PY{n+nx}{then}\PY{p}{(} \PY{p}{(}\PY{n+nx}{p}: \PY{k+kt}{Product}\PY{p}{[}\PY{p}{]}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                 \PY{n+nx}{products} \PY{o}{=} \PY{n+nx}{p}\PY{p}{;}
                 \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Finished loading products\PYZsq{}}\PY{p}{)}\PY{p}{;}
                 
                 \PY{c+c1}{// Loading the \PYZsq{}aisles.csv\PYZsq{} table.}
                 \PY{k}{return} \PY{k}{new} \PY{n+nx}{CSVParser}\PY{p}{.}\PY{n+nx}{CSVParser}\PY{o}{\PYZlt{}}\PY{n+nx}{Aisle}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+s+sb}{`}\PY{l+s+sb}{instacart\PYZus{}basket\PYZus{}data/aisles.csv}\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{.}\PY{n+nx}{loadAll}\PY{p}{(}\PY{p}{)}
             \PY{p}{\PYZcb{}}\PY{p}{)}
             \PY{p}{.}\PY{n+nx}{then}\PY{p}{(} \PY{p}{(}\PY{n+nx}{a}: \PY{k+kt}{Aisle}\PY{p}{[}\PY{p}{]}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                 \PY{n+nx}{aisles} \PY{o}{=} \PY{n+nx}{a}\PY{p}{;}
                 \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Finished loading aisles\PYZsq{}}\PY{p}{)}\PY{p}{;}
                 
                    \PY{c+c1}{// Our custom SPMF wrapper}
                 \PY{k}{new} \PY{n+nx}{SPMF}\PY{p}{.}\PY{n+nx}{SPMF}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}FPGrowth\PYZus{}association\PYZus{}rules\PYZsq{}}\PY{p}{)}
                 \PY{p}{.}\PY{n+nx}{loadResultsFromFile}\PY{o}{\PYZlt{}}\PY{n+nx}{Rule}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}output/output\PYZus{}fpgrowth\PYZus{}assoc\PYZus{}01\PYZus{}25.txt\PYZsq{}}\PY{p}{)}
                 \PY{p}{.}\PY{n+nx}{subscribe}\PY{p}{(}\PY{p}{(}\PY{n+nx}{results}: \PY{k+kt}{SPMFResults}\PY{o}{\PYZlt{}}\PY{n+nx}{Rule}\PY{o}{\PYZgt{}}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                     \PY{c+c1}{// Gather all the aisle\PYZus{}ids}
                     \PY{k+kd}{let} \PY{n+nx}{aislesIds}: \PY{k+kt}{number}\PY{p}{[}\PY{p}{]} \PY{o}{=} \PY{n+nx}{aisles}\PY{p}{.}\PY{n+nx}{map}\PY{p}{(} \PY{p}{(}\PY{n+nx}{aisle}: \PY{k+kt}{Aisle}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{aisle}\PY{p}{.}\PY{n+nx}{aisle\PYZus{}id} \PY{p}{)}\PY{p}{;}
                     
                     \PY{c+c1}{// Series will be aisles, as planned.}
                     \PY{k+kd}{let} \PY{n+nx}{series}: \PY{k+kt}{ChordSerie.ChordSerie}\PY{p}{[}\PY{p}{]} \PY{o}{=} \PY{n+nx}{aisles}\PY{p}{.}\PY{n+nx}{map}\PY{p}{(} \PY{p}{(}\PY{n+nx}{aisle}: \PY{k+kt}{Aisle}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{k}{new} \PY{n+nx}{ChordSerie}\PY{p}{.}\PY{n+nx}{ChordSerie}\PY{p}{(}\PY{n+nx}{aisle}\PY{p}{.}\PY{n+nx}{aisle\PYZus{}id}\PY{p}{)}\PY{p}{.}\PY{n+nx}{setSeriesNumber}\PY{p}{(}\PY{n+nx}{aisles}\PY{p}{.}\PY{n+nx}{length}\PY{p}{)} \PY{p}{)}\PY{p}{;}
                     
                     \PY{c+c1}{// For each rule...}
                     \PY{n+nx}{results}\PY{p}{.}\PY{n+nx}{output}\PY{p}{.}\PY{n+nx}{forEach}\PY{p}{(} \PY{p}{(}\PY{n+nx}{rule}: \PY{k+kt}{Rule}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                         \PY{c+c1}{// Map all aisle\PYZus{}ids the rule is pointing towards.}
                         \PY{k+kd}{let} \PY{n+nx}{indexesOfResults}: \PY{k+kt}{number}\PY{p}{[}\PY{p}{]} \PY{o}{=} \PY{n+nx}{rule}\PY{p}{.}\PY{n+nx}{results}\PY{p}{.}\PY{n+nx}{map}\PY{p}{(} \PY{p}{(}\PY{n+nx}{id}: \PY{k+kt}{string}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{aislesIds}\PY{p}{.}\PY{n+nx}{indexOf}\PY{p}{(} \PY{n+nx}{join}\PY{p}{.}\PY{n+nx}{join}\PY{o}{\PYZlt{}}\PY{n+nx}{Product}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{n+nx}{products}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}product\PYZus{}id\PYZsq{}}\PY{p}{,} \PY{n+nx}{id}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}aisle\PYZus{}id\PYZsq{}}\PY{p}{)} \PY{p}{)} \PY{p}{)}\PY{p}{;}
         
                         \PY{c+c1}{// For each item composing the rule}
                         \PY{n+nx}{rule}\PY{p}{.}\PY{n+nx}{items}\PY{p}{.}\PY{n+nx}{forEach}\PY{p}{(} \PY{p}{(}\PY{n+nx}{id}: \PY{k+kt}{string}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                             \PY{c+c1}{// Get the aisle\PYZus{}id from the product\PYZus{}id}
                             \PY{k+kd}{let} \PY{n+nx}{aisleId}: \PY{k+kt}{number} \PY{o}{=} \PY{n+nx}{join}\PY{p}{.}\PY{n+nx}{join}\PY{o}{\PYZlt{}}\PY{n+nx}{Product}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{n+nx}{products}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}product\PYZus{}id\PYZsq{}}\PY{p}{,} \PY{n+nx}{id}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}aisle\PYZus{}id\PYZsq{}}\PY{p}{)}\PY{p}{;}
                             \PY{c+c1}{// If it\PYZsq{}s ignored, then meh.}
                             \PY{k}{if}\PY{p}{(}\PY{n+nx}{ignoreIds}\PY{p}{.}\PY{n+nx}{includes}\PY{p}{(}\PY{n+nx}{aisleId}\PY{p}{)}\PY{p}{)} \PY{k}{return}\PY{p}{;}
                             
                             \PY{c+c1}{// Else notice the corresponding aisle it has a relation with others.}
                             \PY{k+kd}{let} \PY{n+nx}{index}: \PY{k+kt}{string} \PY{o}{=} \PY{n+nx}{aislesIds}\PY{p}{.}\PY{n+nx}{indexOf}\PY{p}{(} \PY{n+nx}{aisleId} \PY{p}{)}\PY{p}{;}
                             \PY{n+nx}{series}\PY{p}{[}\PY{n+nx}{index}\PY{p}{]}\PY{p}{.}\PY{n+nx}{addRelation}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{n+nx}{indexesOfResults}\PY{p}{)}\PY{p}{;}
                         \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
                     \PY{p}{\PYZcb{}}\PY{p}{)}
                     
                     \PY{k+kd}{let} \PY{n+nx}{chartOptions}: \PY{k+kt}{string} \PY{o}{=}\PY{err}{ }\PY{n+nx}{JSON}\PY{p}{.}\PY{n+nx}{stringify}\PY{p}{(}\PY{p}{\PYZob{}}
                         \PY{n+nx}{id}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}associationRulesChart\PYZsq{}} \PY{o}{+} \PY{n+nx}{ignoreIds}\PY{p}{.}\PY{n+nx}{join}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}\PYZus{}\PYZsq{}}\PY{p}{)}\PY{p}{,}
                         \PY{n+nx}{data}\PY{o}{:} \PY{p}{\PYZob{}}
                             \PY{n+nx}{type}\PY{o}{:}\PY{l+s+s1}{\PYZsq{}chord\PYZsq{}}\PY{p}{,}
                             \PY{n+nx}{title}\PY{o}{:} \PY{p}{\PYZob{}}
                                 \PY{n+nx}{text}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}Implied relations between aisles\PYZsq{}}\PY{p}{,}
                             \PY{p}{\PYZcb{}}\PY{p}{,}
                             \PY{n+nx}{subtitle}\PY{o}{:} \PY{p}{\PYZob{}}
                                 \PY{n+nx}{text}: \PY{k+kt}{ignoreIds.length} \PY{o}{?} \PY{l+s+sb}{`}\PY{l+s+sb}{Aisles ignored : }\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{ignoreIds}\PY{p}{.}\PY{n+nx}{join}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}\PYZus{}\PYZsq{}}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{`} \PY{o}{:} \PY{l+s+s1}{\PYZsq{}\PYZsq{}}
                             \PY{p}{\PYZcb{}}\PY{p}{,}
                             \PY{n+nx}{legend}\PY{o}{:} \PY{p}{\PYZob{}}
                                 \PY{n+nx}{overflow}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}scroll\PYZsq{}}\PY{p}{,}
                                 \PY{n+nx}{layout}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}vertical\PYZsq{}}\PY{p}{,}
                                 \PY{n+nx}{width}: \PY{k+kt}{200}
                             \PY{p}{\PYZcb{}}\PY{p}{,}
                             \PY{n+nx}{options}\PY{o}{:} \PY{p}{\PYZob{}}
                                 \PY{l+s+s1}{\PYZsq{}angle\PYZhy{}padding\PYZsq{}}\PY{o}{:} \PY{l+m+mi}{1}\PY{p}{,}
                                 \PY{l+s+s1}{\PYZsq{}band\PYZhy{}width\PYZsq{}}\PY{o}{:} \PY{l+m+mi}{10}\PY{p}{,}
                                 \PY{l+s+s1}{\PYZsq{}band\PYZhy{}space\PYZsq{}}\PY{o}{:} \PY{l+m+mi}{0}\PY{p}{,}
                                 \PY{l+s+s1}{\PYZsq{}radius\PYZsq{}}\PY{o}{:} \PY{l+m+mi}{190}\PY{p}{,}
                             \PY{l+s+s2}{\PYZdq{}style\PYZdq{}}\PY{o}{:}\PY{p}{\PYZob{}}
                                 \PY{l+s+s2}{\PYZdq{}chord\PYZdq{}}\PY{o}{:}\PY{p}{\PYZob{}}
                                     \PY{l+s+s2}{\PYZdq{}border\PYZhy{}width\PYZdq{}}\PY{o}{:}\PY{l+m+mi}{0}\PY{p}{,}
                                     \PY{l+s+s2}{\PYZdq{}flat\PYZdq{}}\PY{o}{:}\PY{k+kc}{false}
                                 \PY{p}{\PYZcb{}}\PY{p}{,}
                                 \PY{l+s+s2}{\PYZdq{}band\PYZdq{}}\PY{o}{:}\PY{p}{\PYZob{}} \PY{l+s+s2}{\PYZdq{}border\PYZhy{}width\PYZdq{}}\PY{o}{:} \PY{l+m+mi}{0} \PY{p}{\PYZcb{}}\PY{p}{,}
                                 \PY{l+s+s2}{\PYZdq{}tick\PYZdq{}}\PY{o}{:}\PY{p}{\PYZob{}} \PY{l+s+s2}{\PYZdq{}visible\PYZdq{}}\PY{o}{:} \PY{k+kc}{false} \PY{p}{\PYZcb{}}\PY{p}{,}
                                 \PY{l+s+s2}{\PYZdq{}item\PYZdq{}}\PY{o}{:}\PY{p}{\PYZob{}} \PY{l+s+s2}{\PYZdq{}visible\PYZdq{}}\PY{o}{:}\PY{k+kc}{false} \PY{p}{\PYZcb{}}\PY{p}{,}
                                 \PY{l+s+s2}{\PYZdq{}label\PYZdq{}}\PY{o}{:}\PY{p}{\PYZob{}} \PY{l+s+s2}{\PYZdq{}visible\PYZdq{}}\PY{o}{:} \PY{k+kc}{false} \PY{p}{\PYZcb{}}
                             \PY{p}{\PYZcb{}}
                             \PY{p}{\PYZcb{}}\PY{p}{,}
                             \PY{n+nx}{tooltip}\PY{o}{:}\PY{p}{\PYZob{}}\PY{p}{\PYZcb{}}\PY{p}{,}
                             \PY{c+c1}{// Populating with product names}
                             \PY{n+nx}{series}: \PY{k+kt}{series.map}\PY{p}{(} \PY{p}{(}\PY{n+nx}{serie}: \PY{k+kt}{ChordSerie.ChordSerie}\PY{p}{[}\PY{p}{]}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{serie}\PY{p}{.}\PY{n+nx}{getSerie}\PY{p}{(} \PY{p}{(}\PY{n+nx}{id}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{join}\PY{p}{.}\PY{n+nx}{join}\PY{o}{\PYZlt{}}\PY{n+nx}{Aisle}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{n+nx}{aisles}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}aisle\PYZus{}id\PYZsq{}}\PY{p}{,} \PY{n+nx}{id}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}aisle\PYZsq{}}\PY{p}{)} \PY{p}{)} \PY{p}{)}\PY{p}{,}
                         \PY{p}{\PYZcb{}}
                     \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
                     
                     \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{.}\PY{n+nx}{html}\PY{p}{(}\PY{l+s+sb}{`}
         \PY{l+s+sb}{                \PYZlt{}div id=\PYZdq{}associationRulesChart}\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{ignoreIds}\PY{p}{.}\PY{n+nx}{join}\PY{p}{(}\PY{l+s+s1}{\PYZsq{} \PYZsq{}}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{\PYZdq{}\PYZgt{}\PYZlt{}/div\PYZgt{}}
         \PY{l+s+sb}{                \PYZlt{}script\PYZgt{}}
         \PY{l+s+sb}{                  zingchart.render(}\PY{l+s+si}{\PYZdl{}\PYZob{}}\PY{n+nx}{chartOptions}\PY{l+s+si}{\PYZcb{}}\PY{l+s+sb}{);}
         \PY{l+s+sb}{                \PYZlt{}/script\PYZgt{}}
         \PY{l+s+sb}{            }\PY{l+s+sb}{`}\PY{p}{)}\PY{p}{;}
         
                     \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}done}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{(}\PY{p}{)}\PY{p}{;}
                 \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
             \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
         \PY{p}{\PYZcb{}}
         
         \PY{n+nx}{parseAssociationRules}\PY{p}{(}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Parsing association rules, this might take a while{\ldots}
Finished loading products
Finished loading aisles

    \end{Verbatim}

    Graph above enlights us with many interesting information: - You want to
keep \texttt{fresh\ vegetables}, \texttt{packed\ vegetables\ fruits} and
\texttt{fresh\ fruits} aisles as far as possible from each other (which
is definitely a difficult task I concede); - Many rules associate
\texttt{fresh\ fruits} products to products of itself (as we saw
previously): You will have to deal inner aisle organisation !

Let's ignore aisles \texttt{fresh\ vegetables},
\texttt{packed\ vegetables\ fruits} and \texttt{fresh\ fruits} relations
and recompile the graph:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}38}]:} \PY{n+nx}{parseAssociationRules}\PY{p}{(}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}123\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}24\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}83\PYZsq{}}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Parsing association rules, this might take a while{\ldots}
Finished loading products
Finished loading aisles

    \end{Verbatim}

    Many outer relations of associations from other aisles still point
toward \texttt{fresh\ fruit} aisle products. \emph{omnibus viis Romam
pervenitur}.

Though we can still glance some interesting things happening in
\texttt{yoghurt} and \texttt{sparkling\ water\ aisles}, as it seems
products from these aisles are often bought together ! If it actually
definitely sounds silly that people want to buy different kind of
sparkling water at the same time.

As a general conclusion to itemset pattern mining\ldots{} just put the
fresh fruit aisle all across the whole store.

    \hypertarget{sequential-pattern-mining}{%
\subsection{Sequential pattern mining}\label{sequential-pattern-mining}}

Sequential pattern mining consists of discovering interesting
subsequences in a set of sequences (where, has a comparison, mining
frequent itemsets consisted in discovering itemsets in a set of
transaction). In the context of our example, sequential pattern mining
can be used to find the sequences of items frequently bought by
customers, as we acknowledged that transaction data could have be
ordered by time, with the proper table joins (\texttt{orders.csv}). This
can be useful to understand the behavior of customers to take marketing
decisions.

Such a transformation is however pretty heavy, and an already
transformed dataset, \texttt{output/transactions\_seq.txt} is already
provided with this notebook; a 4-columns csv-like file (separators are
tabulation characters) as such: - Column 1: user id; - Column 2: order
number (not an order id, but a number in the sequence of orders); -
Column 3: size of order; - Column 4: list of products in text format
(without spaces), separated by a comma;

In order to mine sequential pattern from our data, we will use the
CloSpan Algorithm, from the SPMF library. This algorithm is used for
discovering \textbf{closed} sequential patterns in sequence databases.
As a closed frequent itemset is to a frequent itemset; a closed
sequential pattern is a sequential pattern such that it is not strictly
included in another pattern having the same support.

\hypertarget{data-formatting}{%
\subsubsection{Data formatting}\label{data-formatting}}

The input file format for SPMF CloSpan is defined as follows:

\begin{itemize}
\tightlist
\item
  Each line represents a sequence from a sequence database, and ends
  with the value -2;
\item
  Each item from a sequence is a positive integer, and items from the
  same itemset within a sequence are order ascendingly, and separated by
  single space;
\item
  Each itemset is separated by the value -1;
\end{itemize}

Example of input from the SPMF Documentation :

\begin{verbatim}
1 -1 1 2 3 -1 1 3 -1 4 -1 3 6 -1 -2
1 4 -1 3 -1 2 3 -1 1 5 -1 -2
5 6 -1 1 2 -1 4 6 -1 3 -1 2 -1 -2
5 -1 7 -1 1 6 -1 3 -1 2 -1 3 -1 -2
\end{verbatim}

Back to our example, the file \texttt{transactions\_sec.txt} has yet be
found quite unusable, as the `comma' has been used as a separator to
separate items within the itemsets, making it impossible to map the
\texttt{product\_names} to their actual id.

\texttt{96980\ \ 15\ \ 10\ Asparagus,GreekExtraVirginOliveOil,Jelly,Blackberry,OrganicButterhead(Boston,Butter,Bibb)Lettuce,OrganicIcebergLettuce,RiceWhip,RipeLargePittedOlives}

In the exemple above, \texttt{Jelly,Blackberry} and
\texttt{OrganicButterhead(Boston,Butter,Bibb)Lettuce} are two separate
products. Thus total count of products is 8, not 10.

Only way to compute this file has been to map all unique
\texttt{strings} to a new integer (in a certain way, to compute our own
\texttt{products.csv} (re-joining both \texttt{orders} and
\texttt{order\_product} is not an easy process). It's a bit sad though
as we won't be able to compute more stats on aisles or departments from
our results.

Here will be the transformations to apply : - Group each order per
\texttt{client\_id}: This will be our sequences; - Map the product to an
integer; - Order and format the sequence as specified.

Algorithm below executes this exact process, for you to tinker with. Two
files have been generated and available for you though. -
\texttt{products\_transactions\_seq.csv}, a map of products to their
`new' unique id; - \texttt{formatted\_transactions\_seq.txt}, the
formatted \texttt{transactions\_sec.txt} as intended.

Few interfaces had to be declaed too:
export interface TransactionSeq {
    user_id: string,
    order_number: string,
    order_size: string,
    products: string
}

export interface ItemSetSeq {
    productIds: number[],
    order: number
}
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}34}]:} \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{CSVParser} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/class/csv\PYZhy{}parser.class.js\PYZsq{}}\PY{p}{;}
         \PY{k+kr}{import} \PY{p}{\PYZob{}} \PY{n+nx}{TransactionSeq} \PY{p}{\PYZcb{}} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./src/interface/transaction\PYZhy{}seq.interface\PYZsq{}}\PY{p}{;}
         \PY{k+kr}{import} \PY{p}{\PYZob{}} \PY{n+nx}{ItemSetSeq} \PY{p}{\PYZcb{}} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./src/interface/item\PYZhy{}set\PYZhy{}seq.interface\PYZsq{}}\PY{p}{;}
         
         \PY{k+kd}{function} \PY{n+nx}{formatTransactionsSeq}\PY{p}{(}\PY{p}{)}\PY{o}{:} \PY{k}{void} \PY{p}{\PYZob{}}
             \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Gathering data, this might take a while...\PYZsq{}}\PY{p}{)}\PY{p}{;}
             \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}aync}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}} \PY{o}{=} \PY{k+kc}{true}\PY{p}{;}
         
             \PY{k+kd}{let} \PY{n+nx}{uniqueProducts}: \PY{k+kt}{string}\PY{p}{[}\PY{p}{]} \PY{o}{=} \PY{p}{[}\PY{p}{]}\PY{p}{;}
             \PY{k+kd}{let} \PY{n+nx}{sequences}: \PY{k+kt}{string}\PY{p}{[}\PY{p}{]} \PY{o}{=} \PY{p}{[}\PY{p}{]}\PY{p}{;}
             
             \PY{c+c1}{// Open the transaction\PYZus{}sec file.}
             \PY{k}{new} \PY{n+nx}{CSVParser}\PY{p}{.}\PY{n+nx}{CSVParser}\PY{o}{\PYZlt{}}\PY{n+nx}{TransactionSeq}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}custom\PYZus{}data/small\PYZus{}transactions\PYZus{}seq.txt\PYZsq{}}\PY{p}{,}\PY{err}{ }\PY{p}{\PYZob{}} \PY{n+nx}{delimiter}\PY{o}{:} \PY{l+s+s1}{\PYZsq{}\PYZbs{}t\PYZsq{}}\PY{p}{,} \PY{n+nx}{columns}: \PY{k+kt}{true} \PY{p}{\PYZcb{}}\PY{p}{)}
                 \PY{c+c1}{// Group by user\PYZus{}id and map TransactionSeq to ItemSetSeq.}
                 \PY{p}{.}\PY{n+nx}{generateItemsets}\PY{o}{\PYZlt{}}\PY{n+nx}{ItemSetSeq}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}user\PYZus{}id\PYZsq{}}\PY{p}{,} \PY{p}{(}\PY{n+nx}{transactionSeq}: \PY{k+kt}{TransactionSeq}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                     \PY{c+c1}{// Parsing products for product\PYZus{}ids.}
                     \PY{k+kd}{let} \PY{n+nx}{productIds}: \PY{k+kt}{number}\PY{p}{[}\PY{p}{]} \PY{o}{=} \PY{n+nx}{transactionSeq}\PY{p}{.}\PY{n+nx}{products}\PY{p}{.}\PY{n+nx}{split}\PY{p}{(}\PY{l+s+s1}{\PYZsq{},\PYZsq{}}\PY{p}{)}\PY{p}{.}\PY{n+nx}{map}\PY{p}{(} \PY{p}{(}\PY{n+nx}{productName}: \PY{k+kt}{string}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                         \PY{c+c1}{// Looking for the productName.}
                         \PY{k+kd}{let} \PY{n+nx}{index}: \PY{k+kt}{number} \PY{o}{=} \PY{n+nx}{uniqueProducts}\PY{p}{.}\PY{n+nx}{indexOf}\PY{p}{(}\PY{n+nx}{productName}\PY{p}{.}\PY{n+nx}{replace}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}\PYZbs{}r\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}\PYZsq{}}\PY{p}{)}\PY{p}{)}\PY{p}{;}
                         \PY{c+c1}{// If the as already been incountered, returning its index.}
                         \PY{k}{if}\PY{p}{(}\PY{n+nx}{index} \PY{o}{\PYZgt{}} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)} \PY{k}{return} \PY{n+nx}{index}\PY{p}{;}
         
                         \PY{c+c1}{// Else adding it to our \PYZsq{}uniqueProducts\PYZsq{} array.}
                         \PY{n+nx}{uniqueProducts}\PY{p}{.}\PY{n+nx}{push}\PY{p}{(}\PY{n+nx}{productName}\PY{p}{)}
                         \PY{k}{return} \PY{n+nx}{uniqueProducts}\PY{p}{.}\PY{n+nx}{length} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1}\PY{p}{;}    
                     \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
         
                     \PY{k}{return} \PY{p}{\PYZob{}}
                         \PY{c+c1}{// Keep in mind that items must be sorted asc. in the itemsets.}
                         \PY{n+nx}{productIds}: \PY{k+kt}{productIds.sort}\PY{p}{(} \PY{p}{(}\PY{n+nx}{a}: \PY{k+kt}{number}\PY{p}{,} \PY{n+nx}{b}: \PY{k+kt}{number}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{a} \PY{o}{\PYZhy{}} \PY{n+nx}{b} \PY{p}{)}\PY{p}{,}
                         \PY{n+nx}{order}: \PY{k+kt}{Number.parseInt}\PY{p}{(}\PY{n+nx}{transactionSeq}\PY{p}{.}\PY{n+nx}{order\PYZus{}number}\PY{p}{)}
                     \PY{p}{\PYZcb{}}\PY{p}{;}
                 \PY{p}{\PYZcb{}}\PY{p}{)}
                 \PY{c+c1}{// Once all the group are gathers and sequences formatted.}
                 \PY{p}{.}\PY{k}{finally}\PY{p}{(} \PY{p}{(}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                     \PY{c+c1}{// Example of output}
                     \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Example of output:\PYZsq{}}\PY{p}{)}\PY{p}{;}
                     \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{n+nx}{sequences}\PY{p}{.}\PY{n+nx}{join}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}\PYZbs{}r\PYZbs{}n\PYZsq{}}\PY{p}{)}\PY{p}{)}\PY{p}{;}
                 
                     
                     \PY{n+nx}{setTimeout}\PY{p}{(} \PY{p}{(}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}done}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{300}\PY{p}{)}\PY{p}{;}
                 \PY{p}{\PYZcb{}}\PY{p}{)}
                 \PY{c+c1}{// Once one group is available.}
                 \PY{p}{.}\PY{n+nx}{subscribe}\PY{p}{(} \PY{p}{(}\PY{n+nx}{group}: \PY{k+kt}{Group}\PY{o}{\PYZlt{}}\PY{n+nx}{TransactionSeq}\PY{p}{,}\PY{n+nx}{ItemSetSeq}\PY{o}{\PYZgt{}}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                     \PY{c+c1}{// Let\PYZsq{}s format groups to a sequence as specified for input}
                     \PY{k+kd}{let} \PY{n+nx}{sequence}: \PY{k+kt}{string} \PY{o}{=} \PY{n+nx}{group}\PY{p}{.}\PY{n+nx}{items}
                         \PY{c+c1}{// Within the groups, we need to sort ItemSetSeq by order asc.}
                         \PY{p}{.}\PY{n+nx}{sort}\PY{p}{(} \PY{p}{(}\PY{n+nx}{a}: \PY{k+kt}{ItemSetSeq}\PY{p}{,} \PY{n+nx}{b}: \PY{k+kt}{ItemSetSeq}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{a}\PY{p}{.}\PY{n+nx}{order} \PY{o}{\PYZhy{}} \PY{n+nx}{b}\PY{p}{.}\PY{n+nx}{order} \PY{p}{)}
                         \PY{c+c1}{// Keep in mind that items are separated by a plain space character within the itemsets.}
                         \PY{p}{.}\PY{n+nx}{map}\PY{p}{(} \PY{p}{(}\PY{n+nx}{itemSetSeq}: \PY{k+kt}{ItemSetSeq}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{n+nx}{itemSetSeq}\PY{p}{.}\PY{n+nx}{productIds}\PY{p}{.}\PY{n+nx}{join}\PY{p}{(}\PY{l+s+s1}{\PYZsq{} \PYZsq{}}\PY{p}{)} \PY{p}{)}
                         \PY{c+c1}{// Each itemset is separated by a \PYZsq{} \PYZhy{}1 \PYZsq{} value}
                         \PY{p}{.}\PY{n+nx}{join}\PY{p}{(}\PY{l+s+s1}{\PYZsq{} \PYZhy{}1 \PYZsq{}}\PY{p}{)}\PY{p}{;}
         
                     \PY{c+c1}{// A sequence ends with \PYZsq{} \PYZhy{}2\PYZsq{}}
                     \PY{n+nx}{sequences}\PY{p}{.}\PY{n+nx}{push}\PY{p}{(}\PY{n+nx}{sequence} \PY{o}{+} \PY{l+s+s1}{\PYZsq{} \PYZhy{}2\PYZsq{}}\PY{p}{)}
                 \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
         \PY{p}{\PYZcb{}}
         
         \PY{n+nx}{formatTransactionsSeq}\PY{p}{(}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Gathering data, this might take a while{\ldots}

    \end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}34}]:} undefined
\end{Verbatim}
            
    \hypertarget{parsing-output}{%
\paragraph{Parsing output}\label{parsing-output}}

The output file introduces yet another format as such: - Each line being
a frequent sequential pattern; - Each itemset being separated by the
value -1; - Support of the sequence is indicated.

Nothing major though, it's only a matter of yet another Regular
Expression to match the results with our current existing code:

Where looking for at least 1 ensemble of a spread of any length of
positive integers \texttt{\textbackslash{}d+} followed by `-1'
\texttt{((\textbackslash{}d+\ )+-1\ )+}, and then followed by `\#SUP :'
and a positive integer \texttt{\#SUP:\ \textbackslash{}d+}.

\begin{verbatim}
Regular expression:
((\d+ )+-1 )+#SUP: \d+
\end{verbatim}

\hypertarget{running-the-algorithm}{%
\subsubsection{Running the algorithm}\label{running-the-algorithm}}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}35}]:} \PY{k+kr}{import} \PY{o}{*} \PY{k+kr}{as} \PY{n+nx}{SPMF} \PY{n+nx}{from} \PY{l+s+s1}{\PYZsq{}./dist/class/spmf.class.js\PYZsq{}}\PY{p}{;}
         
         \PY{k+kd}{function} \PY{n+nx}{sequencesMining}\PY{p}{(}\PY{p}{)}\PY{o}{:} \PY{k}{void} \PY{p}{\PYZob{}}
             \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}async}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}} \PY{o}{=} \PY{k+kc}{true}\PY{p}{;}
             \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Mining sequences, this might take a while...\PYZsq{}}\PY{p}{)}\PY{p}{;}
             \PY{c+c1}{// Our custom SPMF wrapper}
             
             \PY{k}{new} \PY{n+nx}{SPMF}\PY{p}{.}\PY{n+nx}{SPMF}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}CloSpan\PYZsq{}}\PY{p}{)}
             \PY{p}{.}\PY{n+nx}{fromFile}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}custom\PYZus{}data/formatted\PYZus{}transactions\PYZus{}seq.txt\PYZsq{}}\PY{p}{)}
             \PY{p}{.}\PY{n+nx}{exec}\PY{o}{\PYZlt{}}\PY{n+nx}{Sequence}\PY{o}{\PYZgt{}}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{)}
             \PY{p}{.}\PY{n+nx}{subscribe}\PY{p}{(}\PY{p}{(}\PY{n+nx}{results}: \PY{k+kt}{SPMFResults}\PY{o}{\PYZlt{}}\PY{n+nx}{Sequence}\PY{o}{\PYZgt{}}\PY{p}{)} \PY{o}{=}\PY{o}{\PYZgt{}} \PY{p}{\PYZob{}}
                 \PY{c+c1}{// Wrapper returns both the stats...}
                 \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}Stats:\PYZsq{}}\PY{p}{)}\PY{p}{;}
                 \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{n+nx}{results}\PY{p}{.}\PY{n+nx}{stats}\PY{p}{)}\PY{p}{;}
                 \PY{c+c1}{// ... and the frequent sequences. Showing the first two sequecnes:}
                 \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}First two sequences mined:\PYZsq{}}\PY{p}{)}\PY{p}{;}
                 \PY{n+nx}{results}\PY{p}{.}\PY{n+nx}{output}\PY{p}{.}\PY{n+nx}{slice}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}
                 \PY{n+nx}{console}\PY{p}{.}\PY{n+nx}{log}\PY{p}{(}\PY{n+nx}{results}\PY{p}{.}\PY{n+nx}{output}\PY{p}{.}\PY{n+nx}{slice}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}\PY{p}{;}
             
                 \PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}done}\PY{n+nx}{\PYZdl{}}\PY{n+nx}{\PYZdl{}}\PY{p}{(}\PY{p}{)}\PY{p}{;}
             \PY{p}{\PYZcb{}}\PY{p}{)}\PY{p}{;}
         \PY{p}{\PYZcb{}}
         
         \PY{n+nx}{sequencesMining}\PY{p}{(}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Example of output:
0 1 2 3 4 -1 0 2 3 5 6 7 -1 2 3 7 8 9 -1 2 3 4 7 9 -1 2 3 5 7 9 10 11 12 -1 2 3 7 9 -1 2 3 6 7 9 -1 2 3 7 9 13 14 -1 2 3 7 9 13 14 -1 2 3 6 7 9 14 15 16 17 -2
Mining sequences, this might take a while{\ldots}
Stats:
\{ candidates: undefined, executionTime: 596, memory: undefined \}
First two sequences mined:
[ \{ itemsets: [ [Array] ], support: 6084 \},
  \{ itemsets: [ [Array], [Array] ], support: 4045 \} ]

    \end{Verbatim}

    \hypertarget{visualisation-of-sequential-patterns}{%
\subsubsection{Visualisation of sequential
patterns}\label{visualisation-of-sequential-patterns}}

    \hypertarget{references}{%
\subsection{References}\label{references}}

{[}1{]}: ``Kumar, Dr K Ramesh \& D, Usha. (2013). Frequent Pattern
Mining Algorithm for Crime Dataset: An Analysis. INTERNATIONAL JOURNAL
OF ENGINEERING SCIENCES \& RESEARCH.''. Avalaible on
https://www.researchgate.net/publication/266498986\_Frequent\_Pattern\_Mining\_Algorithm\_for\_Crime\_Dataset\_An\_Analysis

{[}2{]}: ``Philippe Fournier Viger. Mining Frequent Closed Itemsets
using the LCM Algorithm. SPMF documentation.''. Avalaible on
http://www.philippe-fournier-viger.com/spmf/LCM.php


    % Add a bibliography block to the postdoc
    
    
    
    \end{document}
